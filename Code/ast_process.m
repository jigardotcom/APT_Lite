% AST_PROCESS() - Process all of the events in EXPLOG, extracting behavioural data for each minigame
%				and updating EEG.event as appropriate
% 				
% Usage:
% 			>> [UpdatedExpLog MDBehData SJBehData SPBehData FOBehData] 
%                       = ast_process(ExpLogStructure);
%
%           >> [UpdatedExpLog MDBehData SJBehData SPBehData FOBehData] 
%                       = ast_process(ExpLogStructure,'key1','val1',...);
% 		
% Inputs:
% 	ExpLog		= the ExpLog to process
%
%   (optional)
%   'indices'   = structure containing the indices of START and END
%                   commands of each minigame
%                   {default is the structure MinigameIndices in 'base'}
%    	
%   'log'       = if present, the path to a file in which to log processing
%                   steps
%                   {default is no log}
%
%   'EEG'       = if set to 0, only process EXPLOG, i.e. do not update EEG
%                 if set to 1, process EXPLOG and attempt to update EEG
%                   {default is 1}
%
% Precondition: ExpLogStructure is a structure of the form generated by 
%                   MakeStructure
% Precondition: MinigameIndices exists in the base workspace, or Indices is
%                   provided
% 
% MDBehData holds the behavioural data for Maritime Defender
%     Go-NoGo Accuracy (GNGAcc)
%     Go-NoGo Latency  (GNGLat)
%     DotCoherence     (DotCoh)
%     Wormhole Accuracy (WHAcc)
%     Wormhole Latency  (WHLat)
% 
% SJBehData holds the behavioural data for StarJack
%     d'prime statistic  		(DPrime)
%     EFT Accuracy       		(EFTAcc)
%     EFT Latency        		(EFTLat)
%     First Order Accuracy		(FOAcc)
%     First Order Latency		(FOLat)
%     Second Order Accuracy		(SOAcc)
%     Second Order Latency		(SOLat)
% 
% SPBehData holds the behavioural data for Stellar Prospector
%     Cued Peripheral Response Accuracy 		(PAccC)
%     Cued Peripheral Response Latency  		(PLatC)
%     Non-Cued Peripheral Response Accuracy		(PAccN)
%     Non-Cued Peripheral Response Latency		(PLatN)
%     Central Response Accuracy    				(CAcc)
%     Central Response Latency     				(CLat)
%
% FOBehData holds the behavioural data for FaceOff
%     Total number of placements                 (Placements)
%     Time between face appearance and placement (Lat)
% 
% see also: ast_process_md.m, ast_process_sj.m, ast_process_sp.m,
% ast_process_as.m, ast_process_fo.m
% 
% Author: Keith Yoder
% Copyright (c) 2010 Cornell University

% This program is free software; you can redistribute it and/or
% modify it under the terms of the GNU General Public License
% as published by the Free Software Foundation; either version 2
% of the License, or (at your option) any later version.
% 
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
% 
% You should have received a copy of the GNU General Public License
% along with this program; if not, write to the Free Software
% Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

% Revision history
% ----------------
% 10/05/27 - kjy3
% Latency stats are now only calculated for correct trials
% DPrime stats are adjusted to avoid NaN and Inf results
%
% 10/04/29 - kjy3
% Added logging capability
%
% 10/02/08 - kjy3
% Added ability for user to specify whether or not to process EEG
%
% 10/03/15 - kjy3
% Collapsed 'StarJack_Level' and 'StarJack_SallyAnne' to 'StarJack' for
% MinigameIndices detection (based on change to ast_updateexplog)


function [ExpLog MDBehData SJBehData SPBehData FOBehData] = ast_process(ExpLogStructure,varargin)
global EXPLOG

% initialize variables
% --------------------
Indices = [];
logpath = [];
EEGExist = [];
logme=0; % 1 to log, 0 to not log
logtoggle = 'off'; % 'off' unless a log path is provided

% check for optional inputs
% -------------------------
if nargin>1
    i=0;
    % inv: args 1..i have been examined and, if necessary, stored
    while i<length(varargin)
        i=i+1;
        if strcmp(varargin{i},'indices'), i=i+1; Indices= varargin{i}; end;
        if strcmp(varargin{i},'log'),i=i+1;logpath=varargin{i};logme=1;end;
        if strcmp(varargin{i},'EEG'),i=i+1;EEGExist=varargin{i};end;
    end
end

% unless EEGExist has been set to 0, check (do not necessarily trust the
% user)
if ~isempty(EEGExist) && EEGExist ~= 0
    EEGExist = evalin('base',strcat('exist(','''','EEG','''',');'));
end
    
PrepTest = 0; %whether or not the EEG file has been prep'ed for processing
if EEGExist == 1
    PrepTest = ast_prepeeg();
    if PrepTest ~=1
        fprintf('EEG exists, but there was a problem preparing it.\n');
        fprintf('Make sure EEG has a valid event channel.\n');
        ExpLog=-1;
        MDBehData=-1;
        SJBehData=-1;
        SPBehData=-1;
        return;
    end
    EEG = evalin('base','EEG;');
end

% if a logpath is provided, open the log file
if logme % open log
    fprintf('Opening log file %s...\n',logpath);
    try    logfid = fopen(logpath,'w');
        fprintf(logfid,...
                    'GInd:\tGTime:\tXInd:\tXTime:\tXCode:\tXName:\t\n');
        logtoggle = 'on';
    catch ME1
        fprintf('Problem opening log.  Logging has been turned off.\n');
        logtoggle = 'off';
        logme = 0;
    end
end

EXPLOG = ExpLogStructure;

%{
MDBehData holds the behavioural data for Maritime Defender
    Go-NoGo Accuracy (GNGAcc)
    Go-NoGo Latency  (GNGLat)
    DotCoherence     (DotCoh)
    Wormhole Accuracy (WHAcc)
    Wormhole Latency  (WHLat)
%}
MDBehData = struct('GNGAcc',0,'GNGLat',0,'DotCoh',0,'WHAcc',0,'WHLat',0);
MDBehData.GNGAcc = []; % holds responses: 1 for correct, 0 for incorrect
MDBehData.GNGLat = []; % holds latency for each response
MDBehData.DotCoh = []; % dot coherence for given trail
MDBehData.WHAcc = []; % holds responses: 1 for correct, 0 for incorrect
MDBehData.WHLat = []; % holds latency from first open-beam until successful wormhole open


%{
SJBehData holds the behaviour data for StarJack
    d'prime statistic  		(DPrime)
    EFT Accuracy       		(EFTAcc)
    EFT Latency        		(EFTLat)
    First Order Accuracy	(FOAcc)
    First Order Latency		(FOLat)
    Second Order Accuracy	(SOAcc)
    Second Order Latency	(SOLat)
%}
SJBehData = struct('DPrime',0,'EFTAcc',0,'EFTLat',0,'AccFO',0,'LatFO',0,'AccSO',0,'LatSO',0);
DPrimeEFTMatrix = [0 0 0 0]; % counts for hit, reject, false alarm, miss 
SJBehData.EFTAcc = []; % holds EFT responses: 1 for correct, 0 for incorrect
SJBehData.EFTLat = []; % holds latency for each EFT response
SJBehData.AccFO = []; % holds SAT FirstOrder responses: 1 for correct, 0 for incorrect
SJBehData.LatFO = []; % holds latency for each SAT FirstOrder response
SJBehData.AccSO = []; % holds SAT SecondOrder responses: 1 for correct, 0 for incorrect
SJBehData.LatSO = []; % holds latency for each SAT SecondOrder response

%{
SPBehData holds the behavioural data for Stellar Prospector
    Cued Peripheral Response Accuracy 		(PAccC)
    Cued Peripheral Response Latency  		(PLatC)
    Non-Cued Peripheral Response Accuracy	(PAccN)
    Non-Cued Peripheral Response Latency	(PLatN)
    Central Response Accuracy    			(CAcc)
    Central Response Latency     			(CLat)
%}
SPBehData = struct('PAccC',0,'PLatC',0,'PAccN',0,'PLatN',0,'CAcc',0,'CLat',0);
SPBehData.PAccC = []; % holds cued, peripheral responses: 1 for correct, 0 for incorrect
SPBehData.PLatC = []; % holds latency for each cued, peripheral response
SPBehData.PAccN = []; % holds non-cued, peripheral responses: 1 for correct, 0 for incorrect
SPBehData.PLatN = []; % holds latency for each non-cued, peripheral response
SPBehData.CAcc = []; % holds central responses: 1 for correct, 0 for incorrect
SPBehData.CLat = []; % holds latency for each central response

% FOBehData holds the behavioural data for FaceOff
%     Total number of placements                 (Placements)
%     Time between face appearance and placement (Lat)
FOBehData = struct('Placements',0,'Lat',0);
FOBehData.Placements = []; % holds the total number of placements per board
FOBehData.Lat = []; % holds latency between last face appearance and placement on game board

%{
Indices
    a structure that holds the indices of the START and END commands 
        in ExpLog for each minigame
        the first cell 'name' contains the name of the minigame
        the second cell 'start' contains the START index
        the third cell 'end' contains the END index
%}
% if no Indices were provided, use MinigameIndices in the base workspace
if isempty(Indices) 
    Indices = evalin('base','MinigameIndices');
end;
startIndex = 0; % index in Indices.start
endIndex = 0; % index in Indices.end

%{ 
Current Game
    0: no game selected
    1: Maritime Defender
    2: StarJack
    3: StellarProspector
    4: Auditory Stimuli
%}
game = 0;

EEGIndex=1; % the current index in EEG.events


k=0;
% inv: EXPLOG[1..k] have been processed
while k < length(EXPLOG)-1
    k = k + 1;
    
    % test for START command by traversing Indices.start
    if startIndex<length(Indices) && k==Indices(startIndex+1).start
        startIndex=startIndex+1;
        endIndex=endIndex+1;
        switch Indices(startIndex).game
            case 'MaritimeDefender'
                game = 1;
            case 'StarJack'
                game = 2;
            case 'StarJack_Level' % three versions of SJ codes are used to ensure
                game = 2;   % backwards and forwards compatibility
            case 'StarJack_SAT'
                game = 2;
            case 'StellarProspector'
                game = 3;
            case 'AuditoryStimuli'
                game = 4;
            case 'FaceOff'
                game = 5;
        end
        fprintf('Now processing codes for %s...\n',Indices(startIndex).game);
        if logme % add processing message to log file
            fprintf(logfid,'Now processing codes for %s...\n',...
                Indices(startIndex).game);
        end
    end
    %if EEG has not been prep'd, process only EXPLOG
    if PrepTest ~=1
        if game~=0
            if logme % log unprocessed code
                if iscell(EXPLOG(k).name)
                    name = EXPLOG(k).name{1};
                else 
                    name = EXPLOG(k).name;
                end
                fprintf(logfid,'n/a\tn/a\t%d\t%4.3g\t%d\t%s\n',k,EXPLOG(k).time,...
                    EXPLOG(k).code,name);
            end
            switch game
                case 1
                    [EXPLOG(k) UBehData logstr] = ast_process_md(EXPLOG(k),k,'log',logtoggle);
                    % update MDBehData
                    MDBehData.GNGAcc = [MDBehData.GNGAcc UBehData.GNGAcc];
                    MDBehData.GNGLat = [MDBehData.GNGLat UBehData.GNGLat];
                    MDBehData.DotCoh = [MDBehData.DotCoh UBehData.DotCoh];
                    MDBehData.WHAcc = [MDBehData.WHAcc UBehData.WHAcc];
                    MDBehData.WHLat = [MDBehData.WHLat UBehData.WHLat];
                case 2
                    [EXPLOG(k) DMatrix UBehData logstr] = ast_process_sj(EXPLOG(k),k,'log',logtoggle);
                    % update StarJack behavioural data
                    DPrimeEFTMatrix = DPrimeEFTMatrix + DMatrix;
                    SJBehData.EFTAcc = [SJBehData.EFTAcc UBehData.EFTAcc];
                    SJBehData.EFTLat = [SJBehData.EFTLat UBehData.EFTLat];
                    SJBehData.AccFO = [SJBehData.AccFO UBehData.AccFO];
                    SJBehData.LatFO = [SJBehData.LatFO UBehData.LatFO];
                    SJBehData.AccSO = [SJBehData.AccSO UBehData.AccSO];
                    SJBehData.LatSO = [SJBehData.LatSO UBehData.LatSO];
                case 3
                    [EXPLOG(k) UBehData logstr] = ast_process_sp(EXPLOG(k),k,'log',logtoggle);
                    % update Stellar Prospector behavioural data
                    SPBehData.PAccC = [SPBehData.PAccC UBehData.PAccC]; 
                    SPBehData.PLatC = [SPBehData.PLatC UBehData.PLatC]; 
                    SPBehData.PAccN = [SPBehData.PAccN UBehData.PAccN]; 
                    SPBehData.PLatN = [SPBehData.PLatN UBehData.PLatN]; 
                    SPBehData.CAcc = [SPBehData.CAcc UBehData.CAcc]; 
                    SPBehData.CLat = [SPBehData.CLat UBehData.CLat];
                case 4
                    [EXPLOG(k) logstr] = ast_process_as(EXPLOG(k),k,'log',logtoggle);
                case 5
                    [EXPLOG(k) UBehData logstr] = ast_process_fo(EXPLOG(k),k,'log',logtoggle);
                    % update FaceOff behavioural data
                    FOBehData.Placements = [FOBehData.Placements UBehData.Placements];
                    FOBehData.Lat = [FOBehData.Lat UBehData.Lat];
            end
        end
    %if EEG has been prep'd, process EEG file along with codes
    else
        % process event
        if game~=0
            if logme % log unprocessed code
                if iscell(EXPLOG(k).name)
                    name = EXPLOG(k).name{1};
                else 
                    name = EXPLOG(k).name;
                end
                fprintf(logfid,'%d\t%4.3g\t%d\t%4.3g\t%d\t%s\n',EEGIndex,...
                    EEG.event(EEGIndex).latency/EEG.srate,k,EXPLOG(k).time,...
                    EXPLOG(k).code,name);
            end
            switch game
                case 1
                    [EXPLOG(k) UBehData logstr UpdatedEEGIndex] = ast_process_md(EXPLOG(k),k,'EEGIndex',EEGIndex,'log',logtoggle);
                    % if UpdatedEEGIndex is greater than 0, update EEGIndex
                    if UpdatedEEGIndex > 0
                        EEGIndex = UpdatedEEGIndex;
                    else
                        fprintf('Problem updating %s EEG event at %d\n',EXPLOG(k).name{1},EEGIndex);
                    end
                    % update MDBehData
                    MDBehData.GNGAcc = [MDBehData.GNGAcc UBehData.GNGAcc];
                    MDBehData.GNGLat = [MDBehData.GNGLat UBehData.GNGLat];
                    MDBehData.DotCoh = [MDBehData.DotCoh UBehData.DotCoh];
                    MDBehData.WHAcc = [MDBehData.WHAcc UBehData.WHAcc];
                    MDBehData.WHLat = [MDBehData.WHLat UBehData.WHLat];
                case 2
                    [EXPLOG(k) DMatrix UBehData logstr UpdatedEEGIndex] = ast_process_sj(EXPLOG(k),k,'EEGIndex',EEGIndex,'log',logtoggle);
                    % if UpdatedEEGIndex is greater than 0, update EEGIndex
                    if UpdatedEEGIndex > 0
                        EEGIndex = UpdatedEEGIndex;
                    else
                        fprintf('Problem updating %s EEG event at %d\n',EXPLOG(k).name{1},EEGIndex);
                    end
                    % update StarJack behavioural data
                    DPrimeEFTMatrix = DPrimeEFTMatrix + DMatrix;
                    SJBehData.EFTAcc = [SJBehData.EFTAcc UBehData.EFTAcc];
                    SJBehData.EFTLat = [SJBehData.EFTLat UBehData.EFTLat];
                    SJBehData.AccFO = [SJBehData.AccFO UBehData.AccFO];
                    SJBehData.LatFO = [SJBehData.LatFO UBehData.LatFO];
                    SJBehData.AccSO = [SJBehData.AccSO UBehData.AccSO];
                    SJBehData.LatSO = [SJBehData.LatSO UBehData.LatSO];
                case 3
                    [EXPLOG(k) UBehData logstr UpdatedEEGIndex] = ast_process_sp(EXPLOG(k),k,'EEGIndex',EEGIndex,'log',logtoggle);
                    % if UpdatedEEGIndex is greater than 0, update EEGIndex
                    if UpdatedEEGIndex > 0
                        EEGIndex = UpdatedEEGIndex;
                    else
                        fprintf('Problem updating %s EEG event at %d\n',EXPLOG(k).name{1},EEGIndex);
                    end
                    % update Stellar Prospector behavioural data
                    SPBehData.PAccC = [SPBehData.PAccC UBehData.PAccC]; 
                    SPBehData.PLatC = [SPBehData.PLatC UBehData.PLatC]; 
                    SPBehData.PAccN = [SPBehData.PAccN UBehData.PAccN]; 
                    SPBehData.PLatN = [SPBehData.PLatN UBehData.PLatN]; 
                    SPBehData.CAcc = [SPBehData.CAcc UBehData.CAcc]; 
                    SPBehData.CLat = [SPBehData.CLat UBehData.CLat];
                case 4
                    [EXPLOG(k) logstr UpdatedEEGIndex] = ast_process_as(EXPLOG(k),k,'EEGIndex',EEGIndex,'log',logtoggle);
                    % if UpdatedEEGIndex is greater than 0, update EEGIndex
                    if UpdatedEEGIndex > 0
                        EEGIndex = UpdatedEEGIndex;
                    else
                        fprintf('Problem updating %s EEG event at %d\n',EXPLOG(k).name{1},EEGIndex);
                    end
                case 5
                    [EXPLOG(k) UBehData logstr UpdatedEEGIndex] = ast_process_fo(EXPLOG(k),k,'EEGIndex',EEGIndex,'log',logtoggle);
                    % if UpdatedEEGIndex is greater than 0, update EEGIndex
                    if UpdatedEEGIndex > 0
                        EEGIndex = UpdatedEEGIndex;
                    else
                        fprintf('Problem updating %s EEG event at %d\n',EXPLOG(k).name{1},EEGIndex);
                    end
                    % update FaceOff behavioural data
                    FOBehData.Placements = [FOBehData.Placements UBehData.Placements];
                    FOBehData.Lat = [FOBehData.Lat UBehData.Lat];
            end
            if logme % log processed code
                fprintf(logfid,'%s\n',logstr);
            end
            end
        end
    % test for END command by tranversing Indices.end
    if endIndex>0 && k>Indices(endIndex).end,game = 0;end;
end

if logme
    try fclose(logfid);
    catch ME2
    end
end

%{
if strncmpi(EXPLOG(k+1).name,'end',3)
    fprintf('File successfully processed...\n');
else
    fprintf('Last code was NOT End of Log!!!\n')
end
%}

%{
    calculate final values for behaviour data
%}

%{
% store raw data in structure MetaData
RawData = struct('MDBehData',0,'SJBehData',0,'SPBehData',0);
RawData.MDBehData = MDBehData;
RawData.SJBehData = SJBehData;
RawData.SPBehData = SPBehData;
%}

% update BehData structures with statistics
MDBehData = GetStats(MDBehData);
SJBehData = GetStats(SJBehData);
SPBehData = GetStats(SPBehData);
FOBehData = GetStats(FOBehData);

% calculate StarJack d'prime statistic
% if any values in DPrimeEFTMatrix are 0, add a trial so that none are zero
DPrimeEFTMatrix(DPrimeEFTMatrix==0)=1;

if (DPrimeEFTMatrix(1)+DPrimeEFTMatrix(4)) == 0 || (DPrimeEFTMatrix(3)+DPrimeEFTMatrix(2))==0
    SJBehData.DPrime = -1;
else
    EFT_HitRate=(DPrimeEFTMatrix(1))/(DPrimeEFTMatrix(1)+DPrimeEFTMatrix(4));
    % calculate false alaram rate
    EFT_FARate=(DPrimeEFTMatrix(3))/(DPrimeEFTMatrix(3)+DPrimeEFTMatrix(2));
    % calculate d'
    SJBehData.DPrime = icdf('Normal',EFT_HitRate,0,1)-icdf('Normal',EFT_FARate,0,1);
end

ExpLog = EXPLOG;
end

function StatData = GetStats(BehData)
% GetStats(BehData)
% for each field in BehData, StatData replaces the field with a 3 field structure:
%	'raw'	the original contents of BehData.<field>
%	'mean'	the mean of the original contents of BehData.<field>
%	'std'	the std of the original contents of BehData.<field>
% Precondition: BehData is a structure containing only 'double' vectors

tmp = struct('raw',0,'mean',0,'std',0);
% get the field names
names = fieldnames(BehData);

size = length(names);

% for each field in BehData, replace the data with 'raw','mean' and 'std' data
i=0;
% inv: fields 1..i have had their data replaced by 'raw', 'mean' and 'std' data
while i<size
	i=i+1;
    if strcmp(names{i},'DotCoh')
        raw = BehData.DotCoh;
        tmp.raw = raw; tmp.mean = mean(raw); tmp.std = std(raw);
    elseif strcmp(names{i},'WHAcc') || strcmp(names{i},'WHLat')
        raw = BehData.(names{i});
        tmp.raw = raw; tmp.mean = mean(raw); tmp.std = std(raw);
    else
        % get the raw data
        raw = eval(strcat('BehData.',names{i},';'));
        % if BehData.<field> is empty, set tmp values to 0
        if isempty(raw)
            tmp.raw=0; tmp.mean = 0; tmp.std = 0;
        else
            % if field is a latency, use only correct trials to computer stats
            if strfind(names{i},'Lat')
                % replace field name 'Lat' with 'Acc'
                accname = regexprep(names{i},'Lat','Acc');
                acc = BehData.(accname);
                % extract indices of correct trials
                raw = raw(acc==1);
            end
            % store raw, mean and std values in tmp
            tmp.raw = raw; tmp.mean = mean(raw); tmp.std = std(raw);
        end
    end
	% add data to StatData
    StatData.(names{i}) = tmp;
end

end
