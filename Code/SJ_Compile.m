% SJ_COMPILE() - Compile behavioural results for the minigame StarJack
%
% This function takes the internal ExpLogStructure and the MinigameIndices
% generated by ast_makestructure.m and gives the behavioural outputs for
% StarJack minigame for the specified subject in one comma
% separated file (.csv file).
%                                                    
% USAGE:                                 
% >> [SJBehData Output]  = SJ_CompileV2(ExpLogStructure,MinigameIndices,filepath)
%
% INPUTS:
% 
%   ExpLogStructure: generated from ast_makestructure.m containing four
%                    structures - code (four digit event code), time (time
%                    of the event),
%                    mark (tick mark), and name (the event string reported).
%   
%   MinigameIndices: For each minigame session it records in its structure
%                    the name of the minigame, start and end of the minigame (the line
%                    numbers in the corresponding ExpLogStructure file)
%                                                                 
%   filepath: the file path obtained from user for saving the .csv result file  
%
% OUTPUTS: 
% SJBehData = holds the following behaviour data for StarJack
%     d'prime statistic  		(DPrime)
%     EFT Accuracy       		(EFTAcc)
%     EFT Latency        		(EFTLat)
% 
% Output  = string that holds the path of the .csv file. 
%
% In the first part of .csv file we get 
% BEHAVIORAL MEASURES RELATED TO EXECUTIVE FUNCTION from the maze event task.
% Behavioural data for the maze task events are computed over here.
% This part counts the number of the following events
%
% 2023 =	SJ_INPUT_Move_Up	 In the maze, the player has pressed the up-arrow to move up.  
% 2024 =	SJ_INPUT_Move_Down	 In the maze, the player has pressed the down-arrow to move down.
% 2025 =	SJ_INPUT_Move_Right	 In the maze, the player has pressed the right-arrow to move right.
% 2026 =	SJ_INPUT_Move_Left	 In the maze, the player has pressed the left-arrow to move left.
% 2033 =	 SJ_INPUT_Interact	 In the maze, the player is interacting with an object or entity.
% 2034 =     SJ_INPUT_LeftClick   (X, Y)=display coordinates	 The player has clicked the left mouse button at the given display coordinates.
% 2009 =	 SJ_Cloak_Start	 In the maze, the player's avatar has activated the invisibility cloak.
% 2010 =	 SJ_Cloak_End	 In the maze, the player's invisibility cloak has deactivated on reaching the end of its allowed time.
% 2011 =	 SJ_TrapPlaced	 In the maze, the player's avatar has set a trap for the guards.
% 2012 =	 SJ_GuardTrapped    (X, Y)=display coordinates	 A trap previously set by the player has captured a guard.
% 2013 =	 SJ_Caught_TeleportToStart	 The player has been seen and caught by a guard or a camera, and teleports back to the starting position.
% 2014 =	 SJ_INPUT_Esc	 The player has pressed the ESCAPE key to pause the game.
% 2015 =	 SJ_MENU_INPUT_Enter	 The player has pressed the enter key to select a sub-portion of the game.
%
%
% Second part of the .csv file gives
% BEHAVIORAL MEASURES RELATED TO PERCEPTUAL DISEMBEDDING for
% Embedded figure test (EFT) task and calculates hits, rejects,
% false alarms and misses based on the following events
%
% 2039 = SJ_EFT_HIT (In the Embedded Figures Test, the SJ_EFT_INPUT_Match event immediately preceding was a correct response.
%        SJ_EFT_INPUT_Match means in the Embedded Figures Test, the player
%        has indicated that the target occurs within the given figure.) 
% 2040 = SJ_EFT_REJECT(In the Embedded Figures Test, the SJ_EFT_INPUT_NoMatch event immediately preceding was a correct response.
%        SJ_EFT_INPUT_NoMatch means in the Embedded Figures Test, the
%        player has indicated that the target does not occur within the
%        given figure.)  
% 2041 = SJ_EFT_FALSE_ALARM (In the Embedded
%        Figures Test, the SJ_EFT_INPUT_Match event immediately preceding was an incorrect response.)
% 2042 = SJ_EFT_MISS (In the Embedded Figures
%        Test, the SJ_EFT_INPUT_NoMatch event immediately preceding was an incorrect response.)              
%
% PRECONDITION: ExpLogStructure considered here is the one that is 
%               generated by ast_makestructure.m BUT NOT already processed
%               by ast_process.m
%  
% see also: APT_Lite.m
 

% Changelog 26-July-2012 ( Jigar Patel)

% - modified programm structure so that most of the data now being stored in
%   different structures/arrrays/cells before printing them out into a .csv file
% - Added Support to the following features:-
%
%             Executive function:- 
% 
%                 - Level-wise compuation of total time elapsed from start to end and mean and STD for time between successive moves.
%                 - cumulative tally of total no of moves, total time spent in executive function modules and mean and STD for time between successive moves.
% 
%             EFT:- 
%                 - D' to be printed in .csv (results) file.
%                 - Mean and STD of EFT reaction time, for correct responses only.
%                 - List out the single-trial reaction times.
% 
%             TOM:-
% 
%                 - Extraction of single-trial data for first order and second order questions in three types of trials: NoTheft (Control condition), UnobservedTheft, ObservedTheft.
%                     - Time taken for the whole trial (SJ_SAT_END - SJ_SAT_START)
%                     - Reaction time(RT) for the response of the First-order(FO) question.
%                     - Correctness condition of the response.
%                     - Reaction time(RT) for the response of the Second-order(SO) question.
%                     - Correctness condition of the response.
%                 - Summary tallies and percentages of Correctness conditions for each of the two question types ( FO & SO) for each of the three theft conditions (NoTheft (Control condition), UnobservedTheft, ObservedTheft)
%                 - For correct responses only, Mean and STD for the followinf reaction time differences:
%                     - First-order question: 
%                         - Unobserved Theft minus No Theft 
%                         - Unobserved Theft minus Observed Theft 
%                         - Unobserved Theft minus (No Theft or Observed Theft, pooled) 
%                     - Second-order question: 
%                         - Observed Theft minus Unobserved Theft 
%                         - Observed Theft minus No Theft 
%                         - Observed Theft minus (Unobserved Theft or No Theft, pooled)

% Authors: Rakesh Sengupta (RS), Aditya Hiran (AH), Jigar Patel (JP)
% 2011 University of Hyderabad
 
% This program is free software; you can redistribute it and/or
% modify it under the terms of the GNU General Public License
% as published by the Free Software Foundation; either version 2
% of the License, or (at your option) any later version.
% 
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
% 
% You should have received a copy of the GNU General Public License
% along with this program; if not, write to the Free Software
% Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

function [SJBehData Output]  = SJ_Compile(ExpLogStructure,MinigameIndices,filepath)

ExpLog = ExpLogStructure;      % ExpLog is a structure containing the log data. The structure has four elements i.e. EventTime, EventMark, EventCode, EventName


Res = fopen(filepath,'w');     % Creates the Result file

% ====  Executive Functions Variables ==== 

Move = []; % Store  moves in N x 7 format where Move = [ Left Right Up Down Time Room Level] ;
MoveCount = 1; % Keeps track of no of moves
MoveLat = 0; % initiliaze the timestamp value to Zero at the start of EFT trial or TOM trial or at the End of minigame session, this ensures that the inter-move latency (time) is robustly calculated.

% A new structure to hold Executive function data, 
% Exf_Data = struct('Room',0,'Level',0,'c_up',0,'c_down',0,'c_right',0,'c_left',0,'c_interact',0,...
%    'c_caught',0,'c_cloak',0,'c_cloak_end',0,'c_trap',0,'c_guard_trapped',0,'c_pause',0,'c_sub',0,'c_left_click',0);
% Where, 
%     c_up			- Move Up
%     c_down			- Move Down
%     c_right			- Move Right
%     c_left			- Move Left
%     c_interact		- No. of times Player interacted with environment
%     c_caught		- No. of times Player got caught
%     c_cloak			- No. of times Player activated clock
%     c_cloak_end		- No. of times clock gets deactivated
%     c_trap			- No. of times Player plants trap
%     c_guard_trapped	- No. of times Player got guard trapped
%     c_pause			- No. of times Player paused game
%     c_sub			- No. of times player has pressed enter to select a sub portion of the game
%     c_left_click	- No. of times player clicked the left button of the mouse at the display coordinates

% P.S. Exf_Data structure will be in an array form which will initialised
% when player starts a new level or enters into a new room.
% DPrimeEFTMatrix = [ 0 0 0 0];

ExfDataCount = 0; % Keeps track of Executive function Trials


% ==== EFT Variables =====

EFT = [ ] ; % Stores EFT Results in N x 8 Array where EFT = [Hit Reject Miss False_Alarm Reaction_Time Key_Code Figure_Code Latency]; *Latency value is for debugging purpose only
EFTCount = 1; % Keeps track of no of EFT TRIALS 


% ==== TOM Variables ==== 

Tom_Lat = []; % Total Time for Theory of Mind Trial

LatFO = []; % Latencies of First Order Trials
LatSO = []; % Latencies of Second Order Trials

AccFO = []; % Accuracy of First Order Trials [ 1 = correct, 0 = incorrect ]
AccSO = []; % Accuracy of Second Order Trials [ 1 = correct, 0 = incorrect ]

CorrCondFO = []; % Correctness condition for First order trials
CorrCondSO = []; % Correctness condition for Second order trials

CorrCondFo_Code = []; 
CorrCondSo_Code = [];

% Correctness Condition Code ( for computional Purpose ) [ 1 = 'NoTheft Correct';
%                                                         2 = 'NoTheft InCorrect';
%                                                         3 = 'Unobserved Theft Correct';
%                                                         4 = 'Unobserved Theft Incorrect TrueLocation';
%                                                         5 = 'Unobserved Theft Incorrect OtherLocation';
%                                                         6 = 'Observed Theft Correct';
%                                                         7 = 'Observed Theft Incorrect TrueLocation';
%                                                         8 = 'Observed Theft Incorrect OtherLocation';

TheftCondFO = []; %  First Order Theft Condition  1 = NoTheft (Control condition), 2 = UnobservedTheft, 3 = ObservedTheft
TheftCondSO = []; %  Second Order Theft Condition 1 = NoTheft (Control condition), 2 = UnobservedTheft, 3 = ObservedTheft

TOMCount = 1; % Keeps track of no of TOM Trials

%{
SJBehData holds the behaviour data for StarJack
    d'prime statistic  		(DPrime)
    EFT Accuracy       		(EFTAcc)
    EFT Latency        		(EFTLat)
%}
% SJBehData = struct('DPrime',0,'EFTAcc',0,'EFTLat',0);
% SJBehData.DPrime = []; % holds the final DPrime calculation for EFT
% SJBehData.EFTAcc = []; % holds EFT responses: 1 for correct, 0 for incorrect
% SJBehData.EFTLat = []; % holds latency for each EFT response
% SJBehData.EFTLat.Raw = [];

%  NEW UPDATED STRUCTURE IS CREATED AT END OF THE PROCESSING...
%######################

fprintf(Res,'\nBEHAVIOURAL MEASURES RELATED TO EXECUTIVE FUNCTION\n');

% From each minigame session get the StarJack minigames on which
% to run the behavioural analysis for their start and end points defined by
% istart and iend which define in which line of ExpLog this particular
% minigame session started and ended.

for j=1:size(MinigameIndices,2)
    % inv: MinigameIndices[1..j] have been processed
    if(  strcmp(MinigameIndices(1,j).game,'StarJack')==1)
        istart=MinigameIndices(1,j).start;
        iend=MinigameIndices(1,j).end;
        
        for i=istart:iend      % Loop over the particular minigame session
        % inv: EXPLOG[istart:i] have been processed
            if(ExpLog(1,i).code == 2002) % Look for SJ_START
                level = str2num(substring(ExpLog(1,i).name{1},20,20)); % Get the level and the room info of the player
                room = str2num(substring(ExpLog(1,i).name{1},31,31));
                % When new level/Room starts, create a new structure to hold data.
                ExfDataCount = ExfDataCount + 1;
                Exf_Data(ExfDataCount) = struct('Room',0,'Level',0,'c_up',0,'c_down',0,'c_right',0,'c_left',0,'c_interact',0,...
                    'c_caught',0,'c_cloak',0,'c_cloak_end',0,'c_trap',0,'c_guard_trapped',0,'c_pause',0,'c_sub',0,'c_left_click',0);
                Exf_Data(ExfDataCount).Room = room ;
                Exf_Data(ExfDataCount).Level = level;
            end
            if(ExpLog(1,i).code == 2038) % Embedded figure test (EFT) stimulus presented
                Lat = ExpLog(1,i).time;
                MoveLat = 0;
                % Look for 2039 = SJ_EFT_HIT (In the Embedded Figures Test, the SJ_EFT_INPUT_Match event immediately preceding was a correct response.
                %                 SJ_EFT_INPUT_Match means in the Embedded
                %                 Figures Test, the player has indicated that the target occurs within the given figure.)
                %          2040 = SJ_EFT_REJECT(In the Embedded Figures Test, the SJ_EFT_INPUT_NoMatch event immediately preceding was a correct response.
                %                 SJ_EFT_INPUT_NoMatch means in the
                %                 Embedded Figures Test, the player has indicated that the target does not occur within the given figure.)
                %          2041 = SJ_EFT_FALSE_ALARM (In the Embedded
                %                 Figures Test, the SJ_EFT_INPUT_Match event immediately preceding was an incorrect response.)
                %          2042 = SJ_EFT_MISS (In the Embedded Figures
                %                 Test, the SJ_EFT_INPUT_NoMatch event immediately preceding was an incorrect response.)
                
                Key1 =  regexp(ExpLog(i).name,'Key[0-9]','match'); % Extract Key Code presented for stimuli;
                Key = Key1{1};
                Key_Code = str2num(Key{1}(4:end));
                
                Figure1 = regexp(ExpLog(i).name,'Figure+','split');
                Figure = Figure1{1};
                Figure_Code = str2num(Figure{3}); % Extract Figure code Presented for stimuli
                
                while i<iend && ~(ExpLog(1,i).code== 2039 || ExpLog(1,i).code == 2040 || ExpLog(1,i).code == 2041 || ExpLog(1,i).code == 2042 )% keep incrementing 'i' until one of the actions occurred.
                    i=i+1;   % inv: ExpLog(1,i).code is not any of these [2039 2040 2041 2042]
                             
                end 
                    
                if(ExpLog(1,i).code == 2039 ) % SJ_EFT_HIT
                    
                    RT=ExpLog(1,i).time - Lat; 
                                        
                    EFT(EFTCount,:) = [1 0 0 0 RT Key_Code Figure_Code ExpLog(1,i).time]; % EFT = [Hit Reject Miss False_Alarm Reaction_Time Key_Code Figure_Code Latency]; *Latency value is for debugging purpose only
                    EFTCount = EFTCount + 1;
                    
                elseif(ExpLog(1,i).code == 2040 ) % SJ_EFT_REJECT
                    
                    RT=ExpLog(1,i).time - Lat;
                                        
                    EFT(EFTCount,:) = [0 1 0 0 RT Key_Code Figure_Code ExpLog(1,i).time];
                    EFTCount = EFTCount + 1;
                    
                elseif(ExpLog(1,i).code == 2041) % SJ_EFT_FALSE_ALARM
                    
                    RT=ExpLog(1,i).time - Lat;
                    
                    EFT(EFTCount,:) = [0 0 0 1 RT Key_Code Figure_Code ExpLog(1,i).time];
                    EFTCount = EFTCount + 1;
                    
                else    % SJ_EFT_MISS
                    
                    RT=ExpLog(1,i).time - Lat;
                    
                    EFT(EFTCount,:) = [0 0 1 0 RT Key_Code Figure_Code ExpLog(1,i).time];
                    EFTCount = EFTCount + 1;
                    
                end
            end % EFT Ends ...
            
            % Behavioural data for the maze task events is computed over here. This
            % part counts the number of the following events
            % 2023 = SJ_INPUT_Move_Up	 In the maze, the player has pressed the up-arrow to move up.
            % 2024 = SJ_INPUT_Move_Down	 In the maze, the player has pressed the down-arrow to move down.
            % 2025 = SJ_INPUT_Move_Right	 In the maze, the player has pressed the right-arrow to move right.
            % 2026 = SJ_INPUT_Move_Left	 In the maze, the player has pressed the left-arrow to move left.
            % 2033 = SJ_INPUT_Interact	 In the maze, the player is interacting with an object or entity.
            % 2034 = SJ_INPUT_LeftClick   (X, Y)=display coordinates	 The player has clicked the left mouse button at the given display coordinates.
            % 2009 = SJ_Cloak_Start	 In the maze, the player's avatar has activated the invisibility cloak.
            % 2010 = SJ_Cloak_End	 In the maze, the player's invisibility cloak has deactivated on reaching the end of its allowed time.
            % 2011 = SJ_TrapPlaced	 In the maze, the player's avatar has set a trap for the guards.
            % 2012 = SJ_GuardTrapped    (X, Y)=display coordinates	 A trap previously set by the player has captured a guard.
            % 2013 = SJ_Caught_TeleportToStart	 The player has been seen and caught by a guard or a camera, and teleports back to the starting position.
            % 2014 = SJ_INPUT_Esc	 The player has pressed the ESCAPE key to pause the game.
            % 2015 = SJ_MENU_INPUT_Enter	 The player has pressed the enter key to select a sub-portion of the game.
            
            if(ExpLog(1,i).code == 2023) % move up
               Exf_Data(ExfDataCount).c_up=Exf_Data(ExfDataCount).c_up+1;
                
                Move(MoveCount,:) = [ 0 0 1 0 0 room level]; % Move = [ Left Right Up Down Time Room Level]
                
                if(MoveLat ~= 0) % MoveLat holds the time point when the last move occurred.
                                 % It is '0' when the move happens to be
                                 % the very first one OR immediately after EFT or TOM trials.
                                 % Thus from MoveLat value, it is possible
                                 % to estimate the time elapsed between successive moves.
                                 % The moves that immediately precede the end of a minigame session OR start of EFT trial
                                 % OR start of TOM trial will have zero
                                 % inter-move latency as the MoveLat
                                 % variable is reset to Zero upon these
                                 % conditions.
                    LastMoveLat = ExpLog(1,i).time - MoveLat;
                    Move(MoveCount-1,:) = Move(MoveCount-1,:) + [0 0 0 0 LastMoveLat 0 0 ];
              
                end
                
                 MoveCount = MoveCount +1;
                MoveLat = ExpLog(1,i).time;
            end
            if(ExpLog(1,i).code == 2024) % move Down
               Exf_Data(ExfDataCount).c_down=Exf_Data(ExfDataCount).c_down+1;
                
                Move(MoveCount,:) = [ 0 0 0 1 0 room level];
                 if(MoveLat ~= 0)
                    LastMoveLat = ExpLog(1,i).time - MoveLat;
                    Move(MoveCount-1,:) = Move(MoveCount-1,:) + [0 0 0 0 LastMoveLat 0 0 ];
                   
                 end
                 
                 MoveCount = MoveCount +1;
                MoveLat = ExpLog(1,i).time;
            end
            if(ExpLog(1,i).code == 2025) % move right
               Exf_Data(ExfDataCount).c_right=Exf_Data(ExfDataCount).c_right+1;
                
                Move(MoveCount,:) = [ 0 1 0 0 0 room level];
                 if(MoveLat ~= 0)
                    LastMoveLat = ExpLog(1,i).time - MoveLat;
                    Move(MoveCount-1,:) = Move(MoveCount-1,:) + [0 0 0 0 LastMoveLat 0 0 ];
                    
                 end
                
                 MoveCount = MoveCount +1;
                 MoveLat = ExpLog(1,i).time;
            end
            if(ExpLog(1,i).code == 2026) % move left 
            Exf_Data(ExfDataCount).c_left=Exf_Data(ExfDataCount).c_left+1;
                
                Move(MoveCount,:) = [ 1 0 0 0 0 room level];
                 if(MoveLat ~= 0)
                    LastMoveLat = ExpLog(1,i).time - MoveLat;
                    Move(MoveCount-1,:) = Move(MoveCount-1,:) + [0 0 0 0 LastMoveLat 0 0 ];
                   
                 end
                 
                 MoveCount = MoveCount +1;
                MoveLat = ExpLog(1,i).time;
            end
            if(ExpLog(1,i).code == 2033) % player is interacting with an object or entity.
                Exf_Data(ExfDataCount).c_interact=Exf_Data(ExfDataCount).c_interact+1;
            end
            if(ExpLog(1,i).code == 2034)  % The player has clicked the left mouse button at the given display coordinates.
                Exf_Data(ExfDataCount).c_left_click=Exf_Data(ExfDataCount).c_left_click+1;
            end
            if(ExpLog(1,i).code == 2013) % The player has been seen and caught by a guard or a camera, and teleports back to the starting position.
                Exf_Data(ExfDataCount).c_caught=Exf_Data(ExfDataCount).c_caught+1;
            end
            if(ExpLog(1,i).code == 2009) %  In the maze, the player's avatar has activated the invisibility cloak.
                Exf_Data(ExfDataCount).c_cloak=Exf_Data(ExfDataCount).c_cloak+1;
            end
            if(ExpLog(1,i).code == 2010) % In the maze, the player's invisibility cloak has deactivated on reaching the end of its allowed time.
                Exf_Data(ExfDataCount).c_cloak_end=Exf_Data(ExfDataCount).c_cloak_end+1;
            end
            if(ExpLog(1,i).code == 2011) %  In the maze, the player's avatar has set a trap for the guards.
                Exf_Data(ExfDataCount).c_trap=Exf_Data(ExfDataCount).c_trap+1;
            end
            if(ExpLog(1,i).code == 2012) %  A trap previously set by the player has captured a guard.
                Exf_Data(ExfDataCount).c_guard_trapped=Exf_Data(ExfDataCount).c_guard_trapped+1;
            end
            if(ExpLog(1,i).code == 2014) % player paused the game (input esc)
                Exf_Data(ExfDataCount).c_pause=Exf_Data(ExfDataCount).c_pause+1;
            end
            if(ExpLog(1,i).code == 2015) % player clicked the left button of the mouse at the display coordinates:
                Exf_Data(ExfDataCount).c_sub=Exf_Data(ExfDataCount).c_sub+1;
            end
           
          % === TOM Code Starts ===
                    
        if(ExpLog(1,i).code == 2052)    % End of SJ minigame session. 
            MoveLat = 0;
            startLat=ExpLog(1,i).time;
        end
        
         if(ExpLog(1,i).code == 2084)
             Tom_Lat1 = ExpLog(1,i).time;
             %case 2084 % SJ_SAT_(First|Second)Order_Question_Presented
             % determine whether question was FirstOrder or SecondOrder
             questionorder = regexp(ExpLog(1,i).name,'(?<=T_)\w*Order','match');
             if isempty(questionorder)
                 error('Problem extracting question order at %d\n',i);
             end
             if iscell(questionorder)
                 questionorder = questionorder{1};
             end
             
             % find next event of the same order
             responseorder = [];
             while i<iend && isempty(responseorder)
                  % inv: ExpLog(i-1).name does not follow expression
                  % '(?<=T_)\w*Order'
                 
                 i=i+1;
                 responseorder = regexp(ExpLog(i).name,'(?<=T_)\w*Order','match');
                 if ~isempty(responseorder)
                     if iscell(responseorder)
                         responseorder = responseorder{1};
                     end
                 end
             end
             
             responsename = ExpLog(1,i).name;
             if iscell(responsename)
                 responsename = responsename{1};
             end
             
             % based on the name of the found event, rename UpdatedEvent.code
             % and UpdatedEvent.name and update AccFO or AccSO
             
             % % Correctness Condition Code ( for computional Purpose ) [ 1 = 'NoTheft Correct';
%                                                         2 = 'NoTheft InCorrect';
%                                                         3 = 'Unobserved Theft Correct';
%                                                         4 = 'Unobserved Theft Incorrect TrueLocation';
%                                                         5 = 'Unobserved Theft Incorrect OtherLocation';
%                                                         6 = 'Observed Theft Correct';
%                                                         7 = 'Observed Theft Incorrect TrueLocation';
%                                                         8 = 'Observed Theft Incorrect OtherLocation';
             
             % FirstOrder
             if strncmpi(responsename,'SJ_SAT_FirstOrder_NoTheft_Correct',30)
                 AccFO(TOMCount) = 1;
                 CorrCondFO{TOMCount}='First Order NoTheft Correct';
                 TheftCondFO(TOMCount) = 1;
                 CorrCondFo_Code(TOMCount) = 1 ;
             elseif strncmpi(responsename,'SJ_SAT_FirstOrder_NoTheft_Incorrect',30)
                 AccFO(TOMCount) = 0;
                 CorrCondFO{TOMCount}='First Order NoTheft InCorrect';
                 TheftCondFO(TOMCount) = 1;
                  CorrCondFo_Code(TOMCount) = 2 ;
             elseif strncmpi(responsename,'SJ_SAT_FirstOrder_Theft_Correct',30)
                 AccFO(TOMCount) = 1;
                 CorrCondFO{TOMCount}='First Order Unobserved Theft Correct';
                 TheftCondFO(TOMCount) = 2;
                  CorrCondFo_Code(TOMCount) = 3 ;
             elseif strncmpi(responsename, 'SJ_SAT_FirstOrder_Theft_IncorrectTrueLocation',30)
                 AccFO(TOMCount) = 0;
                 CorrCondFO{TOMCount}='First Order Unobserved Theft Incorrect TrueLocation';
                 TheftCondFO(TOMCount) = 2;
                  CorrCondFo_Code(TOMCount) = 4 ;
             elseif strncmpi(responsename, 'SJ_SAT_FirstOrder_Theft_IncorrectOtherLocation',30)
                 AccFO(TOMCount) = 0;
                 CorrCondFO{TOMCount}='First Order Unobserved Theft Incorrect OtherLocation';
                 TheftCondFO(TOMCount) = 2;
                  CorrCondFo_Code(TOMCount) = 5 ;
             elseif strncmpi(responsename, 'SJ_SAT_FirstOrder_Scan_Correct',30)
                 AccFO(TOMCount) = 1;
                 CorrCondFO{TOMCount}='First Order Observed Theft Correct';
                 TheftCondFO(TOMCount) = 3;
                  CorrCondFo_Code(TOMCount) = 6 ;
             elseif strncmpi(responsename, 'SJ_SAT_FirstOrder_Scan_IncorrectTrueLocation',30)
                 AccFO(TOMCount) = 0;
                 CorrCondFO{TOMCount}='First Order Observed Theft Incorrect TrueLocation';
                 TheftCondFO(TOMCount) = 3;
                  CorrCondFo_Code(TOMCount) = 7 ;
             elseif strncmpi(responsename, 'SJ_SAT_FirstOrder_Scan_IncorrectOtherLocation',30)
                 AccFO(TOMCount) = 0;
                 CorrCondFO{TOMCount}='First Order Observed Theft Incorrect OtherLocation';
                 TheftCondFO(TOMCount) = 3;
                  CorrCondFo_Code(TOMCount) = 8 ;
                  
                  
                 % SecondOrder
             elseif strncmpi(responsename, 'SJ_SAT_SecondOrder_NoTheft_Correct',30)
                 AccSO(TOMCount) = 1;
                 CorrCondSO{TOMCount}='Second Order NoTheft Correct';
                 TheftCondSO(TOMCount) = 1;
                 CorrCondSo_Code(TOMCount) = 1 ;
             elseif strncmpi(responsename, 'SJ_SAT_SecondOrder_NoTheft_Incorrect',30)
                 AccSO(TOMCount) = 0;
                 CorrCondSO{TOMCount}='Second Order NoTheft InCorrect';
                 TheftCondSO(TOMCount) = 1;
                 CorrCondSo_Code(TOMCount) = 2 ;
             elseif strncmpi(responsename, 'SJ_SAT_SecondOrder_Theft_Correct',30)
                 AccSO(TOMCount) = 1;
                 CorrCondSO{TOMCount}='Second Order Unobserved Theft Correct';
                 TheftCondSO(TOMCount) = 2;
                 CorrCondSo_Code(TOMCount) = 3 ;
             elseif strncmpi(responsename, 'SJ_SAT_SecondOrder_Theft_IncorrectTrueLocation',30)
                 AccSO(TOMCount) = 0;
                 CorrCondSO{TOMCount}='Second Order Unobserved Theft Incorrect TrueLocation';
                 TheftCondSO(TOMCount) =2;
                 CorrCondSo_Code(TOMCount) = 4 ;
             elseif strncmpi(responsename, 'SJ_SAT_SecondOrder_Theft_IncorrectOtherLocation',30)
                 AccSO(TOMCount) = 0;
                 CorrCondSO{TOMCount}='Second Order Unobserved Theft Incorrect OtherLocation';
                 TheftCondSO(TOMCount) = 2;
                 CorrCondSo_Code(TOMCount) = 5 ;
             elseif strncmpi(responsename, 'SJ_SAT_SecondOrder_Scan_IncorrectTrueLocation',30)
                 AccSO(TOMCount) = 0;
                 CorrCondSO{TOMCount}='Second Order Observed Theft Incorrect TrueLocation';
                 TheftCondSO(TOMCount) = 3;
                 CorrCondSo_Code(TOMCount) = 7 ;
             elseif strncmpi(responsename, 'SJ_SAT_SecondOrder_Scan_IncorrectOtherLocation',30)
                 AccSO(TOMCount) = 0;
                 CorrCondSO{TOMCount}='Second Order Observed Theft Incorrect OtherLocation';
                 TheftCondSO(TOMCount) = 3;
                 CorrCondSo_Code(TOMCount) = 8 ;
             elseif strncmpi(responsename, 'SJ_SAT_SecondOrder_Scan_Correct',30)
                 AccSO(TOMCount) = 1;
                 CorrCondSO{TOMCount}='Second Order Observed Theft Correct';
                 TheftCondSO(TOMCount) = 3;
                 CorrCondSo_Code(TOMCount) = 6 ;
                 
             end
             Tom_Lat2 =ExpLog(1,i).time-Tom_Lat1; % Calculate the duration for the trial
             %         %record duration
             %         SATDuration = ast_getduration(ExpLogIndex,i);
             if strcmp(questionorder,'FirstOrder') % assign value to the appropriate variable
                 LatFO(TOMCount) = Tom_Lat2;
             else
                 LatSO(TOMCount) = Tom_Lat2;
             end
         end
            
    
        if(ExpLog(1,i).code == 2053)    % End of TOM trial
            MoveLat = 0;
                endLat=ExpLog(1,i).time;
                Tom_Lat(TOMCount)=endLat-startLat;
                TOMCount = TOMCount + 1 ;

        end
        
        % ==== TOM Code Ends =====

       end
   end
end


Exf_RT1 = Move(Move(:,7)==1,5); % Time taken for Level 1 Moves
Exf_RT2 = Move(Move(:,7)==2,5); % Time taken for Level 2 Moves
Exf_RT = [Exf_RT1;Exf_RT2];     % Commulative tallies of all the moves

for i = 1:ExfDataCount
          % inv: Exf_Data(1..i) have been printed.
                fprintf(Res,'Start level:,');
                fprintf(Res, IsNumber(Exf_Data(i).Level)); % IsNumber() is a custom function which checks whether a perticular variable is number or NaN;
                fprintf(Res,',Room:,');
                fprintf(Res, IsNumber(Exf_Data(i).Room));
                fprintf(Res,'\nNo. of moves UP:,');
                fprintf(Res, IsNumber(Exf_Data(i).c_up));
                fprintf(Res,'\nNo. of moves DOWN:,');
                fprintf(Res, IsNumber(Exf_Data(i).c_down));
                fprintf(Res,'\nNo. of moves RIGHT:,');
                fprintf(Res, IsNumber(Exf_Data(i).c_right));
                fprintf(Res,'\nNo. of moves LEFT:,');
                fprintf(Res, IsNumber(Exf_Data(i).c_left));
                fprintf(Res,'\nNo. of total moves:,');
                fprintf(Res, IsNumber(Exf_Data(i).c_up + Exf_Data(i).c_down + Exf_Data(i).c_right + Exf_Data(i).c_left ));
                fprintf(Res,'\nNo. of times player interacted with an object:,');
                fprintf(Res, IsNumber(Exf_Data(i).c_interact));
                fprintf(Res,'\nNo. of times player was caught:,');
                fprintf(Res, IsNumber(Exf_Data(i).c_caught));
                fprintf(Res,'\nNo. of times cloak was activated:,');
                fprintf(Res, IsNumber(Exf_Data(i).c_cloak));
                fprintf(Res,'\nNo. of times cloak was deactivated:,');
                fprintf(Res, IsNumber(Exf_Data(i).c_cloak_end));
                fprintf(Res,'\nNo. of times trap was set up:,');
                fprintf(Res, IsNumber(Exf_Data(i).c_trap));
                fprintf(Res,'\nNo. of times guard was trapped:,');
                fprintf(Res, IsNumber(Exf_Data(i).c_guard_trapped));
                fprintf(Res,'\nNo. of times player paused the game (input esc):,');
                fprintf(Res, IsNumber(Exf_Data(i).c_pause));
                fprintf(Res,'\nNo. of times player has pressed enter to select a sub portion of the game:,');
                fprintf(Res, IsNumber(Exf_Data(i).c_sub));
                fprintf(Res,'\nNo. of times player clicked the left button of the mouse at the display coordinates:,');
                fprintf(Res, IsNumber(Exf_Data(i).c_left_click));
                fprintf(Res,'\nEnd level\n');
end


fprintf(Res,'\n\nTotal Time for Level 1 (Seconds): ,');
fprintf(Res, IsNumber(sum(Exf_RT1)));

fprintf(Res,'\nMean of Time for Successive Level 1 Moves(Seconds): ,');
fprintf(Res, IsNumber(mean(Exf_RT1)));

fprintf(Res,'\n STD of  Time for Successive Level 1  Moves(Seconds): ,');
fprintf(Res, IsNumber(std(Exf_RT1)));

fprintf(Res,'\n\nTotal Time for Level 2(Seconds): ,');
fprintf(Res, IsNumber(sum(Exf_RT2)));

fprintf(Res,'\nMean of Time for Successive  Level 2  Moves(Seconds): ,');
fprintf(Res, IsNumber(mean(Exf_RT2)));

fprintf(Res,'\n STD of  Time for Successive Level 2  Moves(Seconds): ,');
fprintf(Res, IsNumber(std(Exf_RT2)));

fprintf(Res,'\n\nTotal Time for Level 1 & 2 Pooled(Seconds): ,');
fprintf(Res, IsNumber(sum(Exf_RT)));

fprintf(Res,'\nMean of Time for Successive  Moves (for both level 1 & 2)(Seconds): ,');
fprintf(Res, IsNumber(mean(Exf_RT)));

fprintf(Res,'\n STD of  Time for Successive  Moves(for both level 1 & 2)(Seconds): ,');
fprintf(Res, IsNumber(std(Exf_RT)));

fprintf(Res,'\n\nBEHAVIORAL MEASURES RELATED TO PERCEPTUAL DISEMBEDDING\n');

% Trial By Trial Values / Results for EFT 

fprintf(Res,'\n\n Trial-By-Trial Results for EFT\n');
fprintf(Res,'\n\nResult , RT, Key Code, Figure Code\n');
for i = 1:EFTCount-1
    % inv: Data from EFT(1..i) have been printed.
    if(EFT(i,1) ==1)
        fprintf(Res,'Hit,');
    elseif(EFT(i,2) ==1)
        fprintf(Res,'Reject,');
    elseif(EFT(i,3) ==1)
        fprintf(Res,'Miss,');
    else
        fprintf(Res,'False Alarm,');
    end
    
    fprintf(Res,' %f, %d, %d, \n',EFT(i,5),EFT(i,6),EFT(i,7));
    
end

% calculate StarJack d'prime statistic          EFT = [Hit Reject Miss False_Alarm Reaction_Time Key_Code Figure_Code Latency];

DPrimeEFTMatrix = sum(EFT(:,1:4)); % calculate the total no of Hits, Misses, Rejects and False Alarms to estimate D'
                                   % DPrimeEFTMatrix = [Hits Rejects Misses False Alarms ]

                                   
% if any values in DPrimeEFTMatrix are 0, add a trial so that none are zero

DPrimeEFTMatrix(DPrimeEFTMatrix==0)=1;

EFT_HitRate=(DPrimeEFTMatrix(1))/(DPrimeEFTMatrix(1)+DPrimeEFTMatrix(3));
% calculate false alaram rate
EFT_FARate=(DPrimeEFTMatrix(4))/(DPrimeEFTMatrix(4)+DPrimeEFTMatrix(2));
% calculate d'
DPrime = icdf('Normal',EFT_HitRate,0,1)-icdf('Normal',EFT_FARate,0,1);



fprintf(Res,'\nNo. of Hits:,');
fprintf(Res, IsNumber(DPrimeEFTMatrix(1)));
fprintf(Res,'\nNo. of Rejects:,');
fprintf(Res, IsNumber(DPrimeEFTMatrix(2)));
fprintf(Res,'\nNo. of False_Alarms:,');
fprintf(Res, IsNumber(DPrimeEFTMatrix(4)));
fprintf(Res,'\nNo. of Misses:,');
fprintf(Res, IsNumber(DPrimeEFTMatrix(3)));
fprintf(Res,'\nAccuracy:,');
fprintf(Res, IsNumber((sum(DPrimeEFTMatrix(1:2)))/sum(DPrimeEFTMatrix)));    % accuracy=(no. of hits+no. of rejects)/total no. of trials
% fprintf(Res,'\nHits and Rejects have accuracy 1');

EFT_RT = [EFT(EFT(:,1)==1,5); EFT(EFT(:,2)==1,5)];

fprintf(Res,'\nMean of EFT reaction time (for correct responses only)(Seconds): ,');
fprintf(Res, IsNumber(mean(EFT_RT)));

fprintf(Res,'\nSTD of EFT reaction time (for correct responses only)(Seconds): ,');
fprintf(Res, IsNumber(std(EFT_RT)));

fprintf(Res,'\nD-Prime :,');
fprintf(Res,  IsNumber(DPrime));

% Print Results for Theory of Mind Events

fprintf(Res,'\n\nBEHAVIUORAL MEASURES RELATED TO THEORY OF MIND EVENTS\n');
for i =1:TOMCount-1
    % inv: Behavioural data from sessions(1..i) have been printed.
    fprintf(Res,'\nFor Trial No:,');
    fprintf(Res, IsNumber(i));
    fprintf(Res,'\nTrial Duration:,');
    fprintf(Res, IsNumber(Tom_Lat(i)));
    fprintf(Res,'\nReaction Time for First Order:,');
    fprintf(Res, IsNumber(LatFO(i)));
    fprintf(Res,'\nFirst Order Correctness:,');
    fprintf(Res, IsNumber(AccFO(i)));
    fprintf(Res,'\nFirst Order Correctness Condition:,');
    fprintf(Res,CorrCondFO{i});
    fprintf(Res,'\nReaction Time for Second Order:,');
    fprintf(Res, IsNumber(LatSO(i)));
    fprintf(Res,'\nSecond Order Correctness:,');
    fprintf(Res, IsNumber(AccSO(i)));
    fprintf(Res,'\nSecond Order Correctness Condition:,');
    fprintf(Res,CorrCondSO{i});
    fprintf(Res,'\n');
end

fprintf(Res,'\n\nSummary tallies and percentages of Correctness conditions\n');

fprintf(Res,'\n\nFIRST ORDER\n');

fprintf(Res,'\n\nQuestion Type,NoTheft Correct, NoTheft InCorrect, Unobserved Theft Correct, Unobserved Theft Incorrect TrueLocation, Unobserved Theft Incorrect OtherLocation,Observed Theft Correct, Observed Theft Incorrect TrueLocation, Observed Theft Incorrect OtherLocation, Total\n');
fprintf(Res,'\n\nNoTheft (Control condition),');

% For Reference
% Correctness Condition Code ( for computional Purpose ) [ 1 = 'NoTheft Correct';
%                                                         2 = 'NoTheft InCorrect';
%                                                         3 = 'Unobserved Theft Correct';
%                                                         4 = 'Unobserved Theft Incorrect TrueLocation';
%                                                         5 = 'Unobserved Theft Incorrect OtherLocation';
%                                                         6 = 'Observed Theft Correct';
%                                                         7 = 'Observed Theft Incorrect TrueLocation';
%                                                         8 = 'Observed Theft Incorrect OtherLocation';

NoTheftIndex = (TheftCondFO(1,:)==1);   %  First Order Theft Condition 1= NoTheft (Control condition), 2 = UnobservedTheft, 3 = ObservedTheft

NoTheftCorrectIndexFO = (CorrCondFo_Code(1,:)==1);  % Correctness Condition Code  [ 1 = 'NoTheft_Correct' ]

fprintf(Res, IsNumber(size(CorrCondFo_Code(CorrCondFo_Code(1,NoTheftIndex)==1),2))); % Prints size of array where Correctness condition is = 1 and Theft Condition is = 1, i.e. where 
                                                                                   % there is theft condition is = 'NoTheft' and correctness condition is = 'NoTheft_Correct'
fprintf(Res,',');
fprintf(Res, IsNumber(size(CorrCondFo_Code(CorrCondFo_Code(1,NoTheftIndex)==2),2)));
fprintf(Res,',');
fprintf(Res, IsNumber(size(CorrCondFo_Code(CorrCondFo_Code(1,NoTheftIndex)==3),2)));
fprintf(Res,',');
fprintf(Res, IsNumber(size(CorrCondFo_Code(CorrCondFo_Code(1,NoTheftIndex)==4),2)));
fprintf(Res,',');
fprintf(Res, IsNumber(size(CorrCondFo_Code(CorrCondFo_Code(1,NoTheftIndex)==5),2)));
fprintf(Res,',');
fprintf(Res, IsNumber(size(CorrCondFo_Code(CorrCondFo_Code(1,NoTheftIndex)==6),2)));
fprintf(Res,',');
fprintf(Res, IsNumber(size(CorrCondFo_Code(CorrCondFo_Code(1,NoTheftIndex)==7),2)));
fprintf(Res,',');
fprintf(Res, IsNumber(size(CorrCondFo_Code(CorrCondFo_Code(1,NoTheftIndex)==8),2)));
fprintf(Res,',');
fprintf(Res, IsNumber(sum(NoTheftIndex)));
fprintf(Res,',');


fprintf(Res,'\n\nUnobservedTheft,');

UnobservedTheftIndex = (TheftCondFO(1,:)==2);   %  First Order Theft Condition 1= NoTheft (Control condition), 2 = UnobservedTheft, 3 = ObservedTheft

UnobservedTheftCorrectIndexFO = (CorrCondFo_Code(1,:)==3);  % Correctness Condition Code  [ 3 = 'Theft_Correct' i.e. 'Unobserved Theft Correct']

fprintf(Res, IsNumber(size(CorrCondFo_Code(CorrCondFo_Code(1,UnobservedTheftIndex)==1),2)));
fprintf(Res,',');
fprintf(Res, IsNumber(size(CorrCondFo_Code(CorrCondFo_Code(1,UnobservedTheftIndex)==2),2)));
fprintf(Res,',');
fprintf(Res, IsNumber(size(CorrCondFo_Code(CorrCondFo_Code(1,UnobservedTheftIndex)==3),2)));
fprintf(Res,',');
fprintf(Res, IsNumber(size(CorrCondFo_Code(CorrCondFo_Code(1,UnobservedTheftIndex)==4),2)));
fprintf(Res,',');
fprintf(Res, IsNumber(size(CorrCondFo_Code(CorrCondFo_Code(1,UnobservedTheftIndex)==5),2)));
fprintf(Res,',');
fprintf(Res, IsNumber(size(CorrCondFo_Code(CorrCondFo_Code(1,UnobservedTheftIndex)==6),2)));
fprintf(Res,',');
fprintf(Res, IsNumber(size(CorrCondFo_Code(CorrCondFo_Code(1,UnobservedTheftIndex)==7),2)));
fprintf(Res,',');
fprintf(Res, IsNumber(size(CorrCondFo_Code(CorrCondFo_Code(1,UnobservedTheftIndex)==8),2)));
fprintf(Res,',');
fprintf(Res, IsNumber(sum(UnobservedTheftIndex)));
fprintf(Res,',');

fprintf(Res,'\n\nObservedTheft,');

ObservedTheftIndex = (TheftCondFO(1,:)==3); %  First Order Theft Condition 1= NoTheft (Control condition), 2 = UnobservedTheft, 3 = ObservedTheft

ObservedTheftCorrectIndexFO = (CorrCondFo_Code(1,:)==6);    % Correctness Condition Code  [ 6 = 'Scan_Correct' i.e. 'Observed Theft Correct']

fprintf(Res, IsNumber(size(CorrCondFo_Code(CorrCondFo_Code(1,ObservedTheftIndex)==1),2)));
fprintf(Res,',');
fprintf(Res, IsNumber(size(CorrCondFo_Code(CorrCondFo_Code(1,ObservedTheftIndex)==2),2)));
fprintf(Res,',');
fprintf(Res, IsNumber(size(CorrCondFo_Code(CorrCondFo_Code(1,ObservedTheftIndex)==3),2)));
fprintf(Res,',');
fprintf(Res, IsNumber(size(CorrCondFo_Code(CorrCondFo_Code(1,ObservedTheftIndex)==4),2)));
fprintf(Res,',');
fprintf(Res, IsNumber(size(CorrCondFo_Code(CorrCondFo_Code(1,ObservedTheftIndex)==5),2)));
fprintf(Res,',');
fprintf(Res, IsNumber(size(CorrCondFo_Code(CorrCondFo_Code(1,ObservedTheftIndex)==6),2)));
fprintf(Res,',');
fprintf(Res, IsNumber(size(CorrCondFo_Code(CorrCondFo_Code(1,ObservedTheftIndex)==7),2)));
fprintf(Res,',');
fprintf(Res, IsNumber(size(CorrCondFo_Code(CorrCondFo_Code(1,ObservedTheftIndex)==8),2)));
fprintf(Res,',');
fprintf(Res, IsNumber(sum(ObservedTheftIndex)));
fprintf(Res,',');


fprintf(Res,'\n\nSECOND ORDER\n');

fprintf(Res,'\n\nQuestion Type,NoTheft Correct, NoTheft InCorrect, Unobserved Theft Correct, Unobserved Theft Incorrect TrueLocation, Unobserved Theft Incorrect OtherLocation,Observed Theft Correct, Observed Theft Incorrect TrueLocation, Observed Theft Incorrect OtherLocation, Total\n');

fprintf(Res,'\n\nNoTheft (Control condition),');

NoTheftIndex = (TheftCondSO(1,:)==1);   %  Second Order Theft Condition 1= NoTheft (Control condition), 2 = UnobservedTheft, 3 = ObservedTheft

NoTheftCorrectIndexSO = (CorrCondSo_Code(1,:)==1);  % Correctness Condition Code  [ 1 = 'NoTheft_Correct' ]

fprintf(Res, IsNumber(size(CorrCondSo_Code(CorrCondSo_Code(1,NoTheftIndex)==1),2))); % Prints size of array where Correctness condition is = 1 and Theft Condition is = 1, i.e. where 
                                                                                   % there is theft condition is = 'NoTheft' and correctness condition is = 'NoTheft_Correct'
fprintf(Res,',');
fprintf(Res, IsNumber(size(CorrCondSo_Code(CorrCondSo_Code(1,NoTheftIndex)==2),2)));
fprintf(Res,',');
fprintf(Res, IsNumber(size(CorrCondSo_Code(CorrCondSo_Code(1,NoTheftIndex)==3),2)));
fprintf(Res,',');
fprintf(Res, IsNumber(size(CorrCondSo_Code(CorrCondSo_Code(1,NoTheftIndex)==4),2)));
fprintf(Res,',');
fprintf(Res, IsNumber(size(CorrCondSo_Code(CorrCondSo_Code(1,NoTheftIndex)==5),2)));
fprintf(Res,',');
fprintf(Res, IsNumber(size(CorrCondSo_Code(CorrCondSo_Code(1,NoTheftIndex)==6),2)));
fprintf(Res,',');
fprintf(Res, IsNumber(size(CorrCondSo_Code(CorrCondSo_Code(1,NoTheftIndex)==7),2)));
fprintf(Res,',');
fprintf(Res, IsNumber(size(CorrCondSo_Code(CorrCondSo_Code(1,NoTheftIndex)==8),2)));
fprintf(Res,',');
fprintf(Res, IsNumber(sum(NoTheftIndex)));
fprintf(Res,',');


fprintf(Res,'\n\nUnobservedTheft,');

UnobservedTheftIndex = (TheftCondSO(1,:)==2);   %  Second Order Theft Condition 1= NoTheft (Control condition), 2 = UnobservedTheft, 3 = ObservedTheft

UnobservedTheftCorrectIndexSO = (CorrCondSo_Code(1,:)==3);  % Correctness Condition Code  [ 3 = 'Theft_Correct' i.e. 'Unobserved Theft Correct']

fprintf(Res, IsNumber(size(CorrCondSo_Code(CorrCondSo_Code(1,UnobservedTheftIndex)==1),2)));
fprintf(Res,',');
fprintf(Res, IsNumber(size(CorrCondSo_Code(CorrCondSo_Code(1,UnobservedTheftIndex)==2),2)));
fprintf(Res,',');
fprintf(Res, IsNumber(size(CorrCondSo_Code(CorrCondSo_Code(1,UnobservedTheftIndex)==3),2)));
fprintf(Res,',');
fprintf(Res, IsNumber(size(CorrCondSo_Code(CorrCondSo_Code(1,UnobservedTheftIndex)==4),2)));
fprintf(Res,',');
fprintf(Res, IsNumber(size(CorrCondSo_Code(CorrCondSo_Code(1,UnobservedTheftIndex)==5),2)));
fprintf(Res,',');
fprintf(Res, IsNumber(size(CorrCondSo_Code(CorrCondSo_Code(1,UnobservedTheftIndex)==6),2)));
fprintf(Res,',');
fprintf(Res, IsNumber(size(CorrCondSo_Code(CorrCondSo_Code(1,UnobservedTheftIndex)==7),2)));
fprintf(Res,',');
fprintf(Res, IsNumber(size(CorrCondSo_Code(CorrCondSo_Code(1,UnobservedTheftIndex)==8),2)));
fprintf(Res,',');
fprintf(Res, IsNumber(sum(UnobservedTheftIndex)));
fprintf(Res,',');

fprintf(Res,'\n\nObservedTheft,');

ObservedTheftIndex = (TheftCondSO(1,:)==3); %  Second Order Theft Condition 1= NoTheft (Control condition), 2 = UnobservedTheft, 3 = ObservedTheft

ObservedTheftCorrectIndexSO = (CorrCondSo_Code(1,:)==6);    % Correctness Condition Code  [ 6 = 'Scan_Correct' i.e. 'Observed Theft Correct' ]

fprintf(Res, IsNumber(size(CorrCondSo_Code(CorrCondSo_Code(1,ObservedTheftIndex)==1),2)));
fprintf(Res,',');
fprintf(Res, IsNumber(size(CorrCondSo_Code(CorrCondSo_Code(1,ObservedTheftIndex)==2),2)));
fprintf(Res,',');
fprintf(Res, IsNumber(size(CorrCondSo_Code(CorrCondSo_Code(1,ObservedTheftIndex)==3),2)));
fprintf(Res,',');
fprintf(Res, IsNumber(size(CorrCondSo_Code(CorrCondSo_Code(1,ObservedTheftIndex)==4),2)));
fprintf(Res,',');
fprintf(Res, IsNumber(size(CorrCondSo_Code(CorrCondSo_Code(1,ObservedTheftIndex)==5),2)));
fprintf(Res,',');
fprintf(Res, IsNumber(size(CorrCondSo_Code(CorrCondSo_Code(1,ObservedTheftIndex)==6),2)));
fprintf(Res,',');
fprintf(Res, IsNumber(size(CorrCondSo_Code(CorrCondSo_Code(1,ObservedTheftIndex)==7),2)));
fprintf(Res,',');
fprintf(Res, IsNumber(size(CorrCondSo_Code(CorrCondSo_Code(1,ObservedTheftIndex)==8),2)));
fprintf(Res,',');
fprintf(Res, IsNumber(sum(ObservedTheftIndex)));
fprintf(Res,',');

% First Order RTs for Correct Responces

NoTheft_Lat_FO = LatFO(NoTheftCorrectIndexFO);
UnobservedTheft_Lat_FO = LatFO(UnobservedTheftCorrectIndexFO);
ObservedTheft_Lat_FO = LatFO(ObservedTheftCorrectIndexFO);

% Second Order RTs for Correct Responces

NoTheft_Lat_SO = LatSO(NoTheftCorrectIndexSO);
UnobservedTheft_Lat_SO = LatSO(UnobservedTheftCorrectIndexSO);
ObservedTheft_Lat_SO = LatSO(ObservedTheftCorrectIndexSO);

% Summary tallies of Mean and Std of Reaction Times of Correct Responces 

fprintf(Res,'\n\nSummary tallies of Mean and Std of Reaction Times of Correct Responces \n');

% First Order 

fprintf(Res,'\n\nFIRST ORDER\n');

fprintf(Res,'\n\nTheft Condition, Mean RT, Std RT\n');

fprintf(Res,'\n\nNoTheft (Control condition),');
fprintf(Res, IsNumber(mean(NoTheft_Lat_FO)));
fprintf(Res,',');
fprintf(Res, IsNumber(std(NoTheft_Lat_FO)));
fprintf(Res,',');

fprintf(Res,'\n\nUnobservedTheft,');
fprintf(Res, IsNumber(mean(UnobservedTheft_Lat_FO)));
fprintf(Res,',');
fprintf(Res, IsNumber(std(UnobservedTheft_Lat_FO)));
fprintf(Res,',');

fprintf(Res,'\n\nObservedTheft,');
fprintf(Res, IsNumber(mean(ObservedTheft_Lat_FO)));
fprintf(Res,',');
fprintf(Res, IsNumber(std(ObservedTheft_Lat_FO)));
fprintf(Res,',');

fprintf(Res,'\n\nMean and Std of Reaction Times differences\n');
fprintf(Res,'\nFirst Order Question Type, Mean Difference, STD Difference\n');

fprintf(Res,'\nUnobserved Theft minus No Theft,');
fprintf(Res, IsNumber(mean(UnobservedTheft_Lat_FO)-mean(NoTheft_Lat_FO)));
fprintf(Res,',');
fprintf(Res, IsNumber(std(UnobservedTheft_Lat_FO)-std(NoTheft_Lat_FO)));

fprintf(Res,'\nUnobserved Theft minus Observed Theft,');
fprintf(Res, IsNumber(mean(UnobservedTheft_Lat_FO)-mean(ObservedTheft_Lat_FO)));
fprintf(Res,',');
fprintf(Res, IsNumber(std(UnobservedTheft_Lat_FO)-std(ObservedTheft_Lat_FO)));

fprintf(Res,'\nUnobserved Theft minus (No Theft or Observed Theft - pooled),');
fprintf(Res, IsNumber(mean(UnobservedTheft_Lat_FO)-(mean(ObservedTheft_Lat_FO)+ mean(NoTheft_Lat_FO))));
fprintf(Res,',');
fprintf(Res, IsNumber(std(UnobservedTheft_Lat_FO)-(std(ObservedTheft_Lat_FO)+ std(NoTheft_Lat_FO))));

% Second Order

fprintf(Res,'\n\n SECOND ORDER\n');

fprintf(Res,'\n\nTheft Condition, Mean RT, Std RT\n');

fprintf(Res,'\n\nNoTheft (Control condition),');
fprintf(Res, IsNumber(mean(NoTheft_Lat_SO)));
fprintf(Res,',');
fprintf(Res, IsNumber(std(NoTheft_Lat_SO)));
fprintf(Res,',');

fprintf(Res,'\n\nUnobservedTheft,');
fprintf(Res, IsNumber(mean(UnobservedTheft_Lat_SO)));
fprintf(Res,',');
fprintf(Res, IsNumber(std(UnobservedTheft_Lat_SO)));
fprintf(Res,',');


fprintf(Res,'\n\nObservedTheft,');
fprintf(Res, IsNumber(mean(ObservedTheft_Lat_SO)));
fprintf(Res,',');
fprintf(Res, IsNumber(std(ObservedTheft_Lat_SO)));
fprintf(Res,',');

fprintf(Res,'\n\nMean and Std of Reaction Times differences\n');
fprintf(Res,'\nSecond Order Question Type, Mean Difference, STD Difference\n');

fprintf(Res,'\nUnobserved Theft minus No Theft,');
fprintf(Res, IsNumber(mean(UnobservedTheft_Lat_FO)-mean(NoTheft_Lat_SO)));
fprintf(Res,',');
fprintf(Res, IsNumber(std(UnobservedTheft_Lat_FO)-std(NoTheft_Lat_SO)));

fprintf(Res,'\nUnobserved Theft minus Observed Theft,');
fprintf(Res, IsNumber(mean(UnobservedTheft_Lat_FO)-mean(ObservedTheft_Lat_SO)));
fprintf(Res,',');
fprintf(Res, IsNumber(std(UnobservedTheft_Lat_FO)-std(ObservedTheft_Lat_SO)));

fprintf(Res,'\nUnobserved Theft minus (No Theft or Observed Theft - pooled),');
fprintf(Res, IsNumber(mean(UnobservedTheft_Lat_FO)-(mean(ObservedTheft_Lat_SO)+ mean(NoTheft_Lat_SO))));
fprintf(Res,',');
fprintf(Res, IsNumber(std(UnobservedTheft_Lat_FO)-(std(ObservedTheft_Lat_SO)+ std(NoTheft_Lat_SO))));



% Assigning variables 'EFT' and 'Move' to base workspace for debugging and
% future use.

assignin('base','EFT',EFT);
assignin('base','Move',Move);


SJBehData = struct('EFT',0,'Tom_Lat',0,'LatFO',0,'LatSO',0,'AccFO',0,'AccSO',0,'CorrCondFO',0,'CorrCondSO',0,'CorrCondFo_Code',0,'CorrCondSo_Code',0,'TheftCondFO',0,'TheftCondSO',0,'DPrime',0);

SJBehData.EFT = EFT ; % Stores EFT Results in N x 8 Array where EFT = [Hit Reject Miss False_Alarm Reaction_Time Key_Code Figure_Code Latency]; *Latency value is for debugging purpose only

SJBehData.Tom_Lat = Tom_Lat; % Total Time for Theory of Mind Trial

SJBehData.LatFO = LatFO; % Latencies of First Order Trials
SJBehData.LatSO = LatSO; % Latencies of Second Order Trials

SJBehData.AccFO = AccFO; % Accuracy of First Order Trials [ 1 = correct, 0 = incorrect ]
SJBehData.AccSO = AccSO; % Accuracy of Second Order Trials [ 1 = correct, 0 = incorrect ]

SJBehData.CorrCondFO = CorrCondFO; % Correctness condition for First order trials
SJBehData.CorrCondSO = CorrCondSO; % Correctness condition for Second order trials

SJBehData.CorrCondFo_Code = CorrCondFo_Code; 
SJBehData.CorrCondSo_Code = CorrCondSo_Code;

% Correctness Condition Code ( for computional Purpose ) [ 1 = 'NoTheft Correct';
%                                                         2 = 'NoTheft InCorrect';
%                                                         3 = 'Unobserved Theft Correct';
%                                                         4 = 'Unobserved Theft Incorrect TrueLocation';
%                                                         5 = 'Unobserved Theft Incorrect OtherLocation';
%                                                         6 = 'Observed Theft Correct';
%                                                         7 = 'Observed Theft Incorrect TrueLocation';
%                                                         8 = 'Observed Theft Incorrect OtherLocation';

SJBehData.TheftCondFO = TheftCondFO; %  First Order Theft Condition  1 = NoTheft (Control condition), 2 = UnobservedTheft, 3 = ObservedTheft
SJBehData.TheftCondSO = TheftCondSO; %  Second Order Theft Condition 1 = NoTheft (Control condition), 2 = UnobservedTheft, 3 = ObservedTheft

SJBehData.DPrime = DPrime; % holds the DPrime calculation for EFT

X = fclose(Res);
Output = strcat('The Results of SJ minigame have been saved at: ',filepath);        % Print text to show that the program got executed successfully
