% AST_PROCESS_MD() - Process events for the minigame Maritime Defender, extracting behavioural data and 
%					updating EEG.event as appropriate.
% 				
% Usage:
% 			>> [UpdatedEvent,MDBehData,logstr] = ast_process_md(Event,CurrentExpLogIndex);
% 		else
% 			>> [UpdatedEvent,MDBehData,logstr,newEEGIndex] = ast_process_md(Event,CurrentExpLogIndex,...
%																'key1','val1',...);
% 
% Inputs:
% 	Event				= the event from ExpLog to process
% 	
% 	CurrentExpLogIndex	= the current index in ExpLog
% 
% 	(optional)
% 	'EEGIndex'	= the current index in EEG.event
%                       {default is empty = no EEG}
% 
%   'log'               = 'on'|'off' if 'on', return a string to write to a
%                       log file, otherwise do nothing
%                       {default is empty == off}
%
% Output:
%   UpdatedEvent        = the event from ExpLog with code and name updated
%
%   newEEGIndex         = the current index in EEG after processing
%
%   logstr              = the string to log
%
% 
% Precondition: Event is a structure of the form generated by MakeStructure
% Precondition: If EEGIndex is supplied, there exists an instance of EEG with a valid
% 					event channel.
%
% see also: ast_process.m, ast_process_sj.m, ast_process_sp.m, ast_process_as.m
% 
% Author: Andrew Gross and Keith Yoder
% Copyright (c) 2010 Cornell University

% This program is free software; you can redistribute it and/or
% modify it under the terms of the GNU General Public License
% as published by the Free Software Foundation; either version 2
% of the License, or (at your option) any later version.
% 
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
% 
% You should have received a copy of the GNU General Public License
% along with this program; if not, write to the Free Software
% Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

% Revision History
%
% 11/09/04 - Jigar Patel
% Added 5 Sec Threshold limit to Go-NoGo Events
% ----------------
% 10/04/29 - kjy3
% Added logging capability

function [UpdatedEvent MDBehData logstr newEEGIndex] = ast_process_md(Event, CurrentExpLogIndex, varargin)
global EXPLOG
% initialize variables
EEGIndex = []; % empty unless EEGIndex is provided - then then current index in EEG
newEEGIndex = []; % empty unless EEGIndex was provided - then the index of the processed code in EEG
logtoggle = []; % 0 if 'off', 1 if 'on'
logstr = []; % holds the string to log
P=1; % 1 if given code should be updated, 0 otherwise

% holds the time of the last MD_WormholeOpenSuccess for which a
% MD_ActivateWormholeOpenBeam was encountered - if none, 0
persistent wormholeopentime;

% initialize wormholeopentime to 0
if isempty(wormholeopentime)
    wormholeopentime = 0;
end

% 1 if a wormhole exists on the screen, 0 otherwise
persistent wormholeexist;

% initialize wormholeexist to 0
if isempty(wormholeexist)
    wormholeexist = 0;
end

UpdatedEvent = Event;
Code = Event.code;
Name = Event.name;
if iscell(Name)
    Name=Name{1};
end
ExpLogIndex = CurrentExpLogIndex;

%{
MDBehData holds the behavioural data for Maritime Defender
    Go-NoGo Accuracy (GNGAcc)
    Go-NoGo Latency  (GNGLat)
    DotCoherence     (DotCoh)
    Wormhole Accuracy (WHAcc)
    Wormhole Latency  (WHLat)
%}
MDBehData = struct('GNGAcc',0,'GNGLat',0,'DotCoh',0,'WHAcc',0,'WHLat',0);
MDBehData.GNGAcc = []; % holds responses: 1 for correct, 0 for incorrect
MDBehData.GNGLat = []; % holds latency for each response
MDBehData.DotCoh = []; % dot coherence for given trail
MDBehData.WHAcc = []; % holds responses: 1 for correct, 0 for incorrect
MDBehData.WHLat = []; % holds latency from first open-beam until successful wormhole open

v=0;
% inv: varargin(1..v) have been examined and stored in the appropriate
% local variable
while v<length(varargin)
    v=v+1;
    if isequal(varargin{v},'EEGIndex'),v=v+1;EEGIndex = varargin{v}; end;
    if isequal(varargin{v},'log'),v=v+1;logtoggle = varargin{v}; end;
end

% if logtoggle is set to 'on', replace logtoggle with 1
if ~isempty(logtoggle) && strcmp(logtoggle,'on')
    logtoggle = 1;
else % otherwise set logtoggle to 0
    logtoggle = 0;
end

% if Name is a cell, extract the data from within the cell
% ASSERT: if Name is a cell, data within it is type 'char'
if iscell(Name)
    Name = Name{1};
end

% if Code is a cell, extract the data from within the cell
% ASSERT: if Code is a cell, data within it is type 'double'
if iscell(Code)
    Code = Code{1};
end
% if code is multiple of 1000 (or rescored 1150, 1151), return  (0 codes do not appear in EEG file)
if (mod(Code,1000)==0) || Code==1150 || Code==1151;
    if ~isempty(varargin)
        newEEGIndex=EEGIndex;
        % if logtoggle is 'on', return a string to log
        if logtoggle
            logstr = sprintf('Code %d at %d in ExpLog ends in 0 - EEG not updated\n',...
                Code,ExpLogIndex);
        end
    end
    P=0; % 1 if event should be processed, 0 otherwise
end

%if EEG exists, update the code and name
if P && ~isempty(EEGIndex)
    newEEGIndex = EEGIndex;

    % update the 2-digit code in EEG.event to the 4-digit code in ExpLog
    EEGEventsIndex = ast_searcheeg(Code-1000,newEEGIndex);
    % if Code is not found (e.g. EEGEventsIndex == -1), skip it
    if EEGEventsIndex==-1
        fprintf('Skipping code %d:%s\n',Code,Name);
        % if logtoggle is 'on', return a string to log
        if logtoggle
            logstr = sprintf('Skipping code %d:%s\n',Code,Name);
        end
        P=0;
    else % otherwise update the event in EEG
        % if the event is an 'ignore' event, remove it from EEG.event,
        % decrease the newEEGIndex by 1, and do not process the code
        if strncmpi(Name,'ignore',6)
            P=0;
            EEGEventsIndex = EEGEventsIndex - 1;
            removeTest = ast_removeevent(EEGEventsIndex);
            if removeTest==0
                error('astropolis:ast_process_md:RemoveEventFail',...
                    'Attempted to remove %d from EEG.event(%d)\n',...
                Code,EEGEventsIndex);
            end
        end
        newEEGIndex = EEGEventsIndex;
    end
end

if P
switch Code
     
    %INTERNAL PACING EVENTS
    
    
    case 1032 % MD_BossPhaseBegin
    
    case 1033 % MD_GameSuccess
        
    case 1034 % MD_GameFailure
        
    case 1036 % MD_MENU_INPUT_Left_Click X=??? Y=???
        
    case 1038 % MD_Pause
        
    case 1039 % MD_Pause
   
    case 1041 % MD_MaritimeDefenderGameBegin
   


    %{
    TUTORIAL EVENTS
    %}
        
    case 1007 % MD_ShipIdentifierTestBegin Enemy=Left/Right
    
    case 1008 % MD_ShipIdentifierSelectLeft
        
    case 1009 % MD_ShipIdentifierSelectRight
        
    case 1010 % MD_ShipIdentifierConfirmSelection
        
    case 1011 % MD_ShipIdentifierTestEndSuccess
     
    case 1012 % MD_ShipIdentifierTestEndFailure

        
    %{
    SHOOTER PHASE EVENTS
    %}    

    case 1013 % MD_ShooterPhaseBegin  
        wormholeopentime=Event.time;
    
    case 1014 % MD_ShooterActivateOpenWormholeBeam
        % If a wormhole exists and MD_ShooterActivateOpenWormholeBeam
        % occurs after wormholeopentime, add duration from
        % this MD_ShooterActivateOpenWormholeBeam to
        % MD_ShooterOpenWormholeSuccess to MDBehData.WHLat and calculate
        % the number of successful and unsuccessful OpenWormhole events
        if wormholeexist
            % if MD_ShooterActivateOpenWormholeBeam occurs after
            % wormholeopentime, add duration from this code to
            % MD_ShooterOpenWormholeSuccess to MDBehData.WHLat and
            % calculate the number of successful and unsuccessful
            % OpenWormhole attempts
            if Event.time > wormholeopentime
                % find next MD_ShooterOpenWormholeSuccess
                t=CurrentExpLogIndex+1;
                % ASSERT: EXPLOG(CurrentExpLogIndex).code is 1014
                % inv: EXPLOG(CurrentExpLogIndex..t) are not code:
                %   1016 MD_ShooterOpenWormholeSuccess and for each 1014
                %   encountered, 0 has been appended to MD.WHAcc
                while EXPLOG(t).code ~= 1016 && t<length(EXPLOG)
                    t=t+1;
                    % if code at t is ShooterActivateOpenWormholeBeam, 
                    % score previous code as incorrect and add 0 to MDBehData.WHAcc
                    if EXPLOG(t).code == 1014
                        MDBehData.WHAcc = [MDBehData.WHAcc 0];
                        % find previous ShooterActivateOpenWormholeBeam and
                        % score it as incorrect
                        i=t-1;
                        % inv: codes i..CurrentExpLogIndex-1 are not
                        % ShooterActivateOpenWormholeBeam
                        while EXPLOG(i).code ~=1014 && i>CurrentExpLogIndex;
                            i=i-1;
                        end
                        EXPLOG(i).code = 1151; 
                        EXPLOG(i).name = 'MD_ShooterActivateOpenWormholeFailure';
                    end
                end
                wormholeopentime = EXPLOG(t).time;
                % get duration from CurrentExpLogIndex to t
                MDBehData.WHLat = ast_getduration(CurrentExpLogIndex,t);
                % add one correct response to WHAcc to account for the
                % successful open
                MDBehData.WHAcc = [MDBehData.WHAcc 1];
                % find previous MD_ShooterActivateOpenWormholeBeam and
                % score as 1150, MD_ShooterActivateOpenWormholeSuccess
                i=t;
                % inv: codes i..t are not
                % MD_ShooterActivateOpenWormholeBeam
                while EXPLOG(i).code ~= 1014 && i>CurrentExpLogIndex;
                    i=i-1;
                end
                EXPLOG(i).code = 1150;
                EXPLOG(i).name = 'MD_ShooterActivateOpenWormholeSuccess';
            end
        end % if no wormhole exists, score as: 
        %   1152 MD_ShooterActiveOpenWormholeFalseAlarm
        UpdatedEvent.code = 1152;
        UpdatedEvent.name = 'MD_ShooterActiveOpenWormholeFalseAlarm';
        
    case 1015 % MD_ShooterCeaseOpenWormholeBeam   
        
    case 1151
        
    case 1150
    
    case 1016 % MD_ShooterOpenWormholeSuccess
        wormholeexist = 0;
        % determine whether wormhole contained friend or enemy
        i=ExpLogIndex;
        % inv: codes ExpLogIndex=1..i have been examined
        %   if 1021 - rescore as 1216 or 1217
        %   if 1022 - rescore as 1316 or 1317
        while i<length(EXPLOG) && EXPLOG(i).code~=1021 && EXPLOG(i).code~=1022
            i=i+1;
        end
        if EXPLOG(i).code == 1021
            % determine whether or not friend was responded to
            % correctly
            while i<length(EXPLOG) && ~(EXPLOG(i).code==1028 || EXPLOG(i).code==1024)
                i=i+1;
            end
            % update code and MDBehData
            if EXPLOG(i).code==1028
                UpdatedEvent.name = 'MD_ShooterOpenWormholeSuccess_FriendlyCorrect';
                UpdatedEvent.code = 1216;
            else
                UpdatedEvent.name = 'MD_ShooterOpenWormholeSuccess_FriendlyIncorrect';
                UpdatedEvent.code = 1217;
            end
        elseif EXPLOG(i).code == 1022 % Enemy
            % if 1024 (MD_ShooterActivateFireWeapon) or a movement code appears
            % before 1027 (MD_ShooterEnemyWeaponFired) score
            % as success (1316), otherwise score as a failue (1317)
            i=ExpLogIndex;
            while i<length(EXPLOG) && ...
                  ~(EXPLOG(i).code==1027 || EXPLOG(i).code==1024 || EXPLOG(i).code==1017 || EXPLOG(i).code==1019)
            i=i+1;
            end
            if EXPLOG(i).code == 1027 % MD_ShooterEnemyWeaponFired
                % mark as correct
                UpdatedEvent.code = 1317;
                UpdatedEvent.name = 'MD_ShooterOpenWormholeSuccess_EnemyIncorrect';
            else
                % mark as incorrect
                UpdatedEvent.code = 1316;
                UpdatedEvent.name = 'MD_ShooterOpenWormholeSuccess_EnemyCorrect';
            end            
        else
            error('Wormhole open detected, but no friend or enemy appearance could be found!');
        end
        
    case 1017 % MD_ShooterActivateMovePort  
    
    case 1018 % MD_ShooterCeaseMovePort
        
    case 1019 % MD_ShooterActivateMoveStarboard
        
    case 1020 % MD_ShooterCeaseMoveStarboard
        
    case 1021 % MD_ShooterPresentFriendly
        % ASSERT: EXPLOG(ExpLogIndex).code == 1021
        i=ExpLogIndex;
        
        % inv: codes ExpLogIndex+1..i have been examined
        % if 1028 - MD_ShooterCollectibleSpawned is found before
        % 1024 - MD_ShooterActivateFireWeapon, a movement code (or the end of the log), 
        % score as success (1021) and set MDBehData.GNGAcc to 1, 
        % otherwise score as a failue (1121) and set MDBehData.GNGAcc to 0
        while i<length(EXPLOG) && ...
                ~(EXPLOG(i).code==1028 || EXPLOG(i).code==1024 || EXPLOG(i).code==1017 || EXPLOG(i).code==1019)
            i=i+1;
        end
        % update code and MDBehData
        if ( EXPLOG(i).code==1024 && ast_getduration(ExpLogIndex,i) <= 5) % EDITED : Fixed 5 sec threshold as spaeicified in Wiki
            UpdatedEvent.name = 'MD_ShooterPresentFriendlyIncorrect';
            UpdatedEvent.code = 1121;
            MDBehData.GNGAcc = 0;
        else
            UpdatedEvent.name = 'MD_ShooterPresentFriendlyCorrect';
            UpdatedEvent.code = 1021;
            MDBehData.GNGAcc = 1;
        end
        % get latency and store it in GNGLat
        MDBehData.GNGLat = ast_getduration(ExpLogIndex,i);
    case 1022 % MD_ShooterPresentEnemy
        % if 1024 (MD_ShooterActivateFireWeapon) or a movement code appears
        % before 1027 (MD_ShooterEnemyWeaponFired) score
        % as success (1022) and set MDBehData.GNGAcc to 1, 
        % otherwise score as a failue (1122) and set MDBehData.GNGAcc to 0
        i=ExpLogIndex;
        while i<length(EXPLOG) && ...
                ~(EXPLOG(i).code==1027 || EXPLOG(i).code==1024 || EXPLOG(i).code==1017 || EXPLOG(i).code==1019)
            i=i+1;
        end
        if (EXPLOG(i).code == 1027 && ast_getduration(ExpLogIndex,i) <= 5 )% MD_ShooterEnemyWeaponFired % EDITED : Fixed 5 sec threshold as spaeicified in Wiki
            MDBehData.GNGAcc = 0;
            UpdatedEvent.code = 1122;
            UpdatedEvent.name = 'MD_ShooterPresentEnemyIncorrect';
        else
            UpdatedEvent.code = 1022;
            UpdatedEvent.name = 'MD_ShooterPresentEnemyCorrect';
            MDBehData.GNGAcc = 1;
        end
        % get latency and store it in MDBehData.GNGLat
        MDBehData.GNGLat = ast_getduration(ExpLogIndex,i);
        
    case 1023 % MD_ShooterPresentWormhole 
        % set wormholeexist to 1
        wormholeexist = 1;
    
    case 1024 % MD_ShooterActivateFireWeapon
        
    case 1025 % MD_ShooterCeaseFireWeapon  
    
    case 1026 % MD_ShooterPlayerWeaponFired
        
    case 1027 % MD_ShooterEnemyWeaponFired
        
    case 1028 % MD_ShooterCollectibleSpawned  
    
    case 1029 % MD_ShooterPlayerCollectibleCollision Collectible=Weapon/Credits/Carbon
     
    case 1030 % MD_ShooterMeteorExplosion
        
    case 1031 % MD_ShooterPlayerGetsHit

    %{
    DOT PHASE EVENTS
    %}
    
    case 1000 % MD_DotCount NumDots=???
        
    case 1001 % MD_DotPhaseBegin
     
    case 1002 % MD_DotTrialBegin
        % get dots direction
        dotsDirection = regexp(Name,'(?<=n=).*$','match');
        % get response
        NextName = EXPLOG(ExpLogIndex+1).name;
        response = regexp(NextName,'(?<=nd).*$','match');
        response = response{1};
        % based on dotsDirection, determine correctness of response
        % if response is same as dotsDirection, change event to
        %       code - 1101
        %       name - MD_DotTrialSuccess
        % if response is different from dotsDirection, change event to
        %       code - 1102
        %       name - MD_DotTrialFailure
        % if response is missing (1003 - MD_DotTrialExpire), change to
        %       code - 1103
        %       name - MD_DotTrialMiss
        
        % ASSERT: if response is MD_DotTrialExpire, length(response)==0
        if ~length(response)==0
            if strcmpi(dotsDirection,response)
                UpdatedEvent.code = 1101;
                UpdatedEvent.name = 'MD_DotTrialSuccess';
            else 
                UpdatedEvent.code = 1102;
                UpdatedEvent.name = 'MD_DotTrialFailure';
            end
        else
            UpdatedEvent.code = 1103;
            UpdatedEvent.name = 'MD_DotTrialMiss';
        end
        
        
    case 1003 % MD_DotTrialExpire
    
    case 1004 % MD_DotTrialUserRespondLeft
        % get dots direction
        % ASSERT: EXPLOG(ExpLogIndex-1) is 1002 MD_DotTrialBegin
        PrevName = EXPLOG(ExpLogIndex-1).name;
        
        % if dots are moving left, score Correct; else score incorrect
        if ~isempty(strfind(PrevName,'Success'))
            UpdatedEvent.code = 1201;
            UpdatedEvent.name = 'MD_DotTrialResponseCorrectLeft';
        else
            UpdatedEvent.code = 1202;
            UpdatedEvent.name = 'MD_DotTrialResponseIncorrectLeft';
        end
        
    case 1005 % MD_DotTrialUserRespondRight 
        % get dots direction
        % ASSERT: EXPLOG(ExpLogIndex-1) is 1002 MD_DotTrialBegin
        PrevName = EXPLOG(ExpLogIndex-1).name;
        
        % if dots are moving right, score Correct; else score incorrect
        if ~isempty(strfind(PrevName,'Success'))
            UpdatedEvent.code = 1203;
            UpdatedEvent.name = 'MD_DotResponseCorrectRight';
        else
            UpdatedEvent.code = 1204;
            UpdatedEvent.name = 'MD_DotResponseIncorrectRight';
        end

    
    case 1006 % MD_DotCoherenceEstimate Coherence=?.??
        Coherence = str2double(regexp(EXPLOG(ExpLogIndex).name{1},'(?<=e=)\d.*.$','match'));
        MDBehData.DotCoh = Coherence;
        
    case 1042 % MD_CockpitDamageFeedback
        
    otherwise 
        fprintf('ERROR: Unknown event encountered by process_md\n');
        fprintf('%d - %s at %d in ExpLog\n',Code,Name,ExpLogIndex);
    end % switch end
end

% if EEG exists update the event structure
if ~isempty(EEGIndex)
    %replace the code in EEG.events with its new value
    ast_updateEvent(newEEGIndex,UpdatedEvent.code,'name',UpdatedEvent.name);
end

% if logtoggle is 'on' and a logstr has not been set, update logstr to the new
% code
if logtoggle && isempty(logstr)
    % if either Event.code, UpdatedEvent.code or UpdatedEvent.name is a
    % cell, extract the data contained within
    if iscell(Code)
        Code = Code{1};
    end
    if iscell(UpdatedEvent.code)
        UpdatedEvent.code = UpdatedEvent.code{1};
    end
    if iscell(UpdatedEvent.name)
        UpdatedEvent.name = UpdatedEvent.name{1};
    end
    logstr = sprintf('Event at %d (%d) replaced by %d\t%s\n',...
       ExpLogIndex,Code,UpdatedEvent.code,UpdatedEvent.name);
end
    

