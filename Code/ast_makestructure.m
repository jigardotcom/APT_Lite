% AST_MAKESTRUCTURE() - Read in an ExperimentLog.txt and put that data into a structure
%
%       Because the video game is continually being updated,
%       ast_makestructure attempts to identify (and possible) correct the
%       following (potential) errors:
%           'NULL EVENT LOGGED' 
%               Some event logging produces a the single string 'NULL EVENT LOGGED'
%               Because these codes are known to be unimportant for the extraction
%               of behavioural data and ast_process, these lines are skipped
%
%           Computer restart in the middle of log file
%               If the computer on which the ExperimentLog.txt was
%               generated is restarted, the system cycles (stored in the
%               'mark' field) may be adjusted.  This causes problems
%               because ast_makestructure uses the 'mark' field to sort the
%               ExpLog structure (sorting is necessary because game codes
%               are written in small chunks that may not be in exact
%               chronological order.  
%
%               If ast_makestructure detects a change in mark of greater
%               than 10 percent, a message window warns the user about a
%               potential problem creating the dataset and offers to solve
%               the problem by creating two (or more) separate
%               ExperimentLog.txt files which can then be merged using
%               ast_merge.m
%
%           Game crash
%               If the rare event of a full-system crash, the event-logging
%               may stop mid-line.  If this happens, ast_makestructure
%               alerts the user to a bad code line and quits.
%           
%
% Usage:
%			>> [UpdatedExpLog success GameStartIndices MinigameIndicies] =
%			ast_makestructure(filepath) 

% #####      Modified to Provide RAW Explog for Pre-Processing
%
% Input:
%	filepath	= the path to ExperimentLog.txt
%
% Precondition: filepath identifies a log file generated by the game Astropolis
% 
% 	UpdatedExpLog - the data from ExperimentLog.txt
%		'code' 	(double) the numerical code of the event
%		'name'	(string) name of the event
%		'time'	(double) time (in msec) since the beginning of the log at which the event occured
%		'mark'	(double) cycles
%
% 	GameStartIndices - START indices for each minigame in ExpLog (archiac)
%		'game' 	(string) holds the name of the minigame
%		'start'	(double) holds the index of the minigame START command
%						
% 	MinigameIndices - START and END indices for each minigame in ExpLog
%		'game'	(string) name of the minigame
%		'start'	(double) index of the minigame START command in ExpLog
%		'end'	(double) index of the minigame END command in ExpLog
%
% See also: ast_updateexplog.m, ast_readfile.m
%
% Author: Keith Yoder
% Copyright (c) 2010 Cornell University

% This program is free software; you can redistribute it and/or
% modify it under the terms of the GNU General Public License
% as published by the Free Software Foundation; either version 2
% of the License, or (at your option) any later version.
% 
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
% 
% You should have received a copy of the GNU General Public License
% along with this program; if not, write to the Free Software
% Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
%
% Revision history
% ----------------
% 11/09/06 - jp (JigarPatel)
%   Added a function to calculate the total number of lines in BehavLog file 
%   Added code segment to discard events with event code 0 and are labelled
%   with substring 'IGNORE' in its event name 

function [UpdatedExpLog success GameStartIndices MinigameIndices] = ast_makestructure(filepath)

fprintf('Attempting to open %s...\n', filepath);

%{
    Initialize return values
%}
UpdatedExpLog=0;
success=0;
GameStartIndices=0;
MinigameIndices=0;


% attempt to open the filepath
try
    fid = fopen(filepath,'r');
    % check to ensure fopen command worked
    if fid < 3 % error reading file
        fprintf('ERROR: Problem reading %s.\n',filepath);
        fprintf('To try again, run ReadFile.m again.\n');
        return;
    end
catch ME1
    % print last segment of the error message identifier.
    errortxt = regexp(ME1.identifier, '(?<=:)\w+$', ...
               'match');
    fprintf('ERROR: %s\n',errortxt{1});
    fprintf('ERROR: Problem reading %s.\n',filepath);
    success=0;
    return;
end
    
run = 1; % 0 if current line of file is -1 (EOF - end of file)
numberOfLines = 0; % holds the number of lines that have been processed
badLines = 0; % holds the number of lines to skip

disp('Creating structure ExpLog...');
% initialize ExpLog - the structure that will store the data
ExpLog = struct('code',0,'name',0,'time',0,'mark',0); 

%[status result] = system(['wc -l ',filepath]);
%totlines = str2double(result);


%######################### jp's addition 11/09/06 #######

totlines = Totallines(filepath);

%###############################

fprintf('Beginning with line 1 of %d...\n',totlines);

last_mark = 0; % holds the last mark
split_index = []; % the indices of codes at which to split the file

% inv: lines 1..numberOfLines have been parsed, sorted by lowest time, 
% stored in ExpLog and current line is not EOF
while run
    numberOfLines=numberOfLines+1;
    ExpLogLine=fgetl(fid);
    % if EOF, set run to 0
    if ExpLogLine==-1
    	run = 0;
    elseif strfind(ExpLogLine,'NULL EVENT LOGGED') % skip
        badLines = badLines+1;
    else
	    % parse line for time, mark, code and name and store in
	    % ExpLog.time, ExpLog.mark, ExpLog.code and ExpLog.name respectively

        % extract TIME
        % ------------
        % parse for time, convert resulting string to class 'double'
        EventTime = regexp(ExpLogLine,...
            '\d{3,4}\.\d{6}','match');
        EventTime = str2double(EventTime);

        % extract MARK
        % ------------
        % parse for mark, convert resulting string to class 'double'
        EventMark = regexp(ExpLogLine,...
            '(?<=\d{6}\s)\d{9,14}','match');
        EventMark = str2double(EventMark);
        
        % compare to previous mark, if EventMark is more than 10 percent
        % different than previous mark warn user and suggest creating
        % multiple log files
        
         %######## DISABLED ...
%         if last_mark~=0 % if there is no previous mark, do not compare
%             if abs((last_mark - EventMark))/last_mark > .3
%                 if numberOfLines ~= totlines % do not count last line of log
%                     split_index = [split_index numberOfLines];  
%                 end
%             end 
%         end
%         last_mark = EventMark;
        
        % extract CODE
        % ------------
        % parse for code, convert resulting string to class 'double'
        EventCode = regexp(ExpLogLine,...
            '(?<=\d{9,14}\s)\d{1,6}','match');
        EventCode = str2double(EventCode);
        
        % extract NAME
        % ------------
        % parse for name
        EventName = regexp(ExpLogLine,...
            '(?<=(?<=\d{9,14}\s)\d{1,6}\s).+.$', 'match');
        % store parsed values in respective fields of ExpLog at the
        % appropriate index
        
        %###################### jp's addition 11/09/06 #######
        % Discard events with event code 0 and are labelled with
        % substring 'IGNORE' in its event name
        
        if(strfind(ExpLogLine,'IGNORE')) 
            if (EventCode == 0)
                badLines = badLines+1;
            else
                ExpLog(numberOfLines-badLines).code=EventCode;
                ExpLog(numberOfLines-badLines).name=EventName;
                ExpLog(numberOfLines-badLines).time=EventTime;
                ExpLog(numberOfLines-badLines).mark=EventMark;
            end
        else
            
            ExpLog(numberOfLines-badLines).code=EventCode;
            ExpLog(numberOfLines-badLines).name=EventName;
            ExpLog(numberOfLines-badLines).time=EventTime;
            ExpLog(numberOfLines-badLines).mark=EventMark;
        end
        
        %###############################################################
        
        % maintain time-ordering
        i = numberOfLines;
        % if the EventTime is empty or has more than one value, warn the
        % user and do not include the code in the structure
        if isempty(EventTime) || length(EventTime)>1
            fclose(fid);
            error('MakeStructure:BadLine','Problem with time at line %d:\n(%s)',i,ExpLogLine);
        elseif isempty(EventCode)
            fclose(fid);
            error('MakeStructure:BadLine','Problem with code at line %d:\n(%s)',i,ExpLogLine);
        end
    end
    if mod(numberOfLines,5000)==0
    	fprintf('Successfully processed %d of %d lines...\n',numberOfLines,totlines);
    end
end

% if there are any potention splitting points, warn the user ## Disabled ...
% if ~isempty(split_index)
%     beep
%     queststr = strcat(...
%         'WARNING: AST_MAKESTRUCTURE has detected large changes in\n',...
%         'cycles between adjacent pairs of codes in the log file:\n',...
%         '%s.\n',...
%         'Would you like AST_MAKESTRUCTURE to split the log at these places?\n',...
%         '(This will create multiple, numbered ExperimentLog files)\n',...
%         'Failing to do so will likely cause problems for processing');
%     response = questdlg(sprintf(queststr,filepath),'Problem detected','Yes');
%     % if user selects 'No', 'Cancel' or closes the window, do
%     % nothing
%     if strcmp(response,'No') || strcmp(response,'Cancel') || isempty(response)
%     else % otherwise, split the log at numberOfLines
%         fclose(fid);    
%         ast_splitfile(filepath,split_index);
%         helpstr = strcat(...
%             'You can use AST_MERGELOGS to combine split files.');
%         helpdlg(helpstr,'AST_MERGELOGS');
%         return
%     end
% end


%###########################################################  DISABLED ...
% sort ExpLog by mark
% fprintf('Sorting ExpLog...\n');
% oldExpLog = ExpLog;
% [sorted order] = sort([oldExpLog.mark]);
% % inv: ordered events 1..i have been added to ExpLog
% for i=1:length(ExpLog)
%     ExpLog(i) = oldExpLog(order(i));
% end


% close the file
fclose(fid);
success = 1;
fprintf('File successfully read.  %g lines detected\n',numberOfLines-badLines - 1 )

% rescore to four-digit codes
[UpdatedExpLog GameStartIndices MinigameIndices] = ast_updateexplog(ExpLog);
end